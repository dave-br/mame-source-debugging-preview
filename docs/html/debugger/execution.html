<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Execution Debugger Commands &mdash; MAME Documentation 0.281 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/documentation_options.js?v=4c6de409"></script>
        <script src="../_static/doctools.js?v=9bcbadda"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Breakpoint Debugger Commands" href="breakpoint.html" />
    <link rel="prev" title="Memory Debugger Commands" href="memory.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MAME Documentation
          </a>
              <div class="version">
                0.281
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../whatis.html">What is MAME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../healthwarning.html">Health Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../initialsetup/index.html">Getting MAME prepared</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingmame/index.html">Basic MAME Usage and Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../commandline/index.html">MAME Command-line Usage and OS-Specific Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plugins/index.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/index.html">Advanced configuration</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">MAME Debugger</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="general.html">General Debugger Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory.html">Memory Debugger Commands</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Execution Debugger Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="breakpoint.html">Breakpoint Debugger Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="watchpoint.html">Watchpoint Debugger Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="registerpoints.html">Registerpoint Debugger Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="exceptionpoint.html">Exceptionpoint Debugger Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="annotation.html">Code Annotation Debugger Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="cheats.html">Cheat Debugger Commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="image.html">Media Image Debugger Commands</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../luascript/index.html">Lua Scripting Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">MAME External Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributing to MAME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../techspecs/index.html">Technical Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../security.html">MAME and security concerns</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">The MAME License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MAME Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">MAME Debugger</a></li>
      <li class="breadcrumb-item active">Execution Debugger Commands</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="execution-debugger-commands">
<span id="debugger-execution-list"></span><h1>Execution Debugger Commands<a class="headerlink" href="#execution-debugger-commands" title="Link to this heading">¶</a></h1>
<dl class="simple">
<dt><a class="reference internal" href="#debugger-command-step"><span class="std std-ref">step</span></a></dt><dd><p>single step for &lt;count&gt; instructions (F11, when disassembly view is active)</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-steps"><span class="std std-ref">steps</span></a></dt><dd><p>single step one source line (F11, when source view is active)</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-over"><span class="std std-ref">over</span></a></dt><dd><p>single step over &lt;count&gt; instructions (F10, when disassembly view is active)</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-overs"><span class="std std-ref">overs</span></a></dt><dd><p>single step over one source line (F10, when source view is active)</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-out"><span class="std std-ref">out</span></a></dt><dd><p>single step until the current subroutine/exception handler returns
(Shift-F11)</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-go"><span class="std std-ref">go</span></a></dt><dd><p>resume execution (F5)</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-gbt"><span class="std std-ref">gbt</span></a></dt><dd><p>resume execution until next true branch is executed</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-gbf"><span class="std std-ref">gbf</span></a></dt><dd><p>resume execution until next false branch is executed</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-gex"><span class="std std-ref">gex</span></a></dt><dd><p>resume execution until exception is raised</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-gint"><span class="std std-ref">gint</span></a></dt><dd><p>resume execution until interrupt is taken (F7)</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-gni"><span class="std std-ref">gni</span></a></dt><dd><p>resume execution until next further instruction</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-gtime"><span class="std std-ref">gtime</span></a></dt><dd><p>resume execution until the given delay has elapsed</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-gvblank"><span class="std std-ref">gvblank</span></a></dt><dd><p>resume execution until next vertical blanking interval (F8)</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-next"><span class="std std-ref">next</span></a></dt><dd><p>resume execution until the next CPU switch (F6)</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-focus"><span class="std std-ref">focus</span></a></dt><dd><p>focus debugger only on &lt;CPU&gt;</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-ignore"><span class="std std-ref">ignore</span></a></dt><dd><p>stop debugging on &lt;CPU&gt;</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-observe"><span class="std std-ref">observe</span></a></dt><dd><p>resume debugging on &lt;CPU&gt;</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-trace"><span class="std std-ref">trace</span></a></dt><dd><p>trace the specified CPU to a file</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-traceover"><span class="std std-ref">traceover</span></a></dt><dd><p>trace the specified CPU to a file skipping subroutines</p>
</dd>
<dt><a class="reference internal" href="#debugger-command-traceflush"><span class="std std-ref">traceflush</span></a></dt><dd><p>flush all open trace files.</p>
</dd>
</dl>
<section id="step">
<span id="debugger-command-step"></span><h2>step<a class="headerlink" href="#step" title="Link to this heading">¶</a></h2>
<p><strong>s[tep] [&lt;count&gt;]</strong></p>
<p>Single steps one or more instructions on the currently executing CPU.
Executes one instruction if <strong>&lt;count&gt;</strong> is omitted, or steps <strong>&lt;count&gt;</strong>
instructions if it is supplied.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">s</span></code></dt><dd><p>Steps forward one instruction on the current CPU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">4</span></code></dt><dd><p>Steps forward four instructions on the current CPU.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="steps">
<span id="debugger-command-steps"></span><h2>steps<a class="headerlink" href="#steps" title="Link to this heading">¶</a></h2>
<p><strong>steps</strong></p>
<p>When <a class="reference internal" href="index.html#srcdbg"><span class="std std-ref">source-level debugging</span></a> is enabled, this single-steps
one <em>source</em> line on the currently executing CPU.  When the original
source is assembly language, <code class="docutils literal notranslate"><span class="pre">step</span></code> and <code class="docutils literal notranslate"><span class="pre">steps</span></code> generally behave the same.
But when the original source is in a higher level language like C or BASIC,
<code class="docutils literal notranslate"><span class="pre">steps</span></code> results in executing the remainder of a block of instructions
associated with the current source line.</p>
<p>If the current source line is a
call instruction, <code class="docutils literal notranslate"><span class="pre">steps</span></code> stops at the first source line in the called
function, but only if the called function has source associated with it.
If neither the called function nor any of its callees have source associated
with them, <code class="docutils literal notranslate"><span class="pre">steps</span></code> will continue execution until the call is complete, and
the first instruction with source associated with it is encountered.</p>
<p>If the current line returns from a recursive function, <code class="docutils literal notranslate"><span class="pre">steps</span></code> will stop
at the same line, but in the prior call frame.  It will appear as if
no stepping occurred, but the stack register will indicate a return
has occurred.  Note that this logic can be fooled when stepping into a function
without associated source, which makes further calls without proper
matching returns (using direct manipulation of the stack pointer instead).</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">steps</span></code></dt><dd><p>Steps forward to the next source line on the current CPU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">sts</span></code></dt><dd><p>Steps forward to the next source line on the current CPU.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="over">
<span id="debugger-command-over"></span><h2>over<a class="headerlink" href="#over" title="Link to this heading">¶</a></h2>
<p><strong>o[ver] [&lt;count&gt;]</strong></p>
<p>The over command single steps “over” one or more instructions on the
currently executing CPU, stepping over subroutine calls and exception
handler traps and counting them as a single instruction.  Note that when
stepping over a subroutine call, code may execute on other CPUs before
the subroutine returns.</p>
<p>Steps over one instruction if <strong>&lt;count&gt;</strong> is omitted, or steps over
<strong>&lt;count&gt;</strong> instructions if it is supplied.</p>
<p>Note that the step over functionality may not be implemented for all CPU
types.  If it is not implemented, then <code class="docutils literal notranslate"><span class="pre">over</span></code> will behave exactly like
<a class="reference internal" href="#debugger-command-step"><span class="std std-ref">step</span></a>.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">o</span></code></dt><dd><p>Steps forward over one instruction on the current CPU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">over</span> <span class="pre">4</span></code></dt><dd><p>Steps forward over four instructions on the current CPU.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="overs">
<span id="debugger-command-overs"></span><h2>overs<a class="headerlink" href="#overs" title="Link to this heading">¶</a></h2>
<p><strong>overs</strong></p>
<p>When <a class="reference internal" href="index.html#srcdbg"><span class="std std-ref">source-level debugging</span></a> is enabled, this steps forward
over one <em>source</em> line on the currently executing CPU.  When the original
source is assembly language, <code class="docutils literal notranslate"><span class="pre">over</span></code> and <code class="docutils literal notranslate"><span class="pre">overs</span></code> generally behave the same.
But when the original source is in a higher level language like C or BASIC,
<code class="docutils literal notranslate"><span class="pre">overs</span></code> results in executing the remainder of a block of instructions
associated with the current source line.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">overs</span></code></dt><dd><p>Steps forward over the next source line on the current CPU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">os</span></code></dt><dd><p>Steps forward over the next source line on the current CPU.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="out">
<span id="debugger-command-out"></span><h2>out<a class="headerlink" href="#out" title="Link to this heading">¶</a></h2>
<p><strong>out</strong></p>
<p>Single steps until a return from subroutine or return from exception
instruction is encountered.  Note that because it detects return from
exception conditions, if you attempt to step out of a subroutine and an
interrupt/exception occurs before the subroutine completes, execution
may stop prematurely at the end of the exception handler.</p>
<p>Note that the step out functionality may not be implemented for all CPU
types.  If it is not implemented, then <code class="docutils literal notranslate"><span class="pre">out</span></code> will behave exactly like
<a class="reference internal" href="#debugger-command-step"><span class="std std-ref">step</span></a>.</p>
<p>Example:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">out</span></code></dt><dd><p>Steps until a subroutine or exception handler returns.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="outs">
<span id="debugger-command-outs"></span><h2>outs<a class="headerlink" href="#outs" title="Link to this heading">¶</a></h2>
<p><strong>outs</strong></p>
<p>When <a class="reference internal" href="index.html#srcdbg"><span class="std std-ref">source-level debugging</span></a> is enabled, this single-steps
until the next return from subroutine or return from exception instruction
lands the currently executing CPU to a <em>source</em> line.  When the original
source is assembly language and source-level debugging information is provided
for the current and calling subroutine, <code class="docutils literal notranslate"><span class="pre">out</span></code> and <code class="docutils literal notranslate"><span class="pre">outs</span></code> generally
behave the same.  But when layers of functions or subroutines <em>without</em>
source-level information exist between the current instruction and the
most recent calling instruction <em>with</em> source-level information, <code class="docutils literal notranslate"><span class="pre">outs</span></code>
will skip over those &quot;non source-level information&quot; layers until it lands on
calling code with source-level information.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">outs</span></code></dt><dd><p>Steps until a subroutine or exception handler returns to code with
source-level information.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="go">
<span id="debugger-command-go"></span><h2>go<a class="headerlink" href="#go" title="Link to this heading">¶</a></h2>
<p><strong>g[o] [&lt;address&gt;]</strong></p>
<p>Resumes execution.  Control will not be returned to the debugger until a
breakpoint or watchpoint is triggered, or a debugger break is manually
requested.  If the optional <strong>&lt;address&gt;</strong> is supplied, a temporary
unconditional breakpoint will be set for the visible CPU at the
specified address.  It will be cleared automatically when triggered.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">g</span></code></dt><dd><p>Resume execution until a breakpoint/watchpoint is triggered, or a
break is manually requested.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">1234</span></code></dt><dd><p>Resume execution, stopping at address 1234, unless another condition
causes execution to stop before then.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="gbf">
<span id="debugger-command-gbf"></span><h2>gbf<a class="headerlink" href="#gbf" title="Link to this heading">¶</a></h2>
<p><strong>gbf [&lt;condition&gt;]</strong></p>
<p>Resumes execution.  Control will not be returned to the debugger until
a breakpoint or watchpoint is triggered, or until a conditional branch
or skip instruction is not taken, following any delay slots.</p>
<p>The optional <strong>&lt;condition&gt;</strong> parameter lets you specify an expression
that will be evaluated each time a conditional branch is encountered.
If the result of the expression is true (non-zero), execution will be
halted after the branch if it is not taken; otherwise, execution will
continue with no notification.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gbf</span></code></dt><dd><p>Resume execution until a breakpoint/watchpoint is triggered, or
until the next false branch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gbf</span> <span class="pre">{pc</span> <span class="pre">!=</span> <span class="pre">1234}</span></code></dt><dd><p>Resume execution until the next false branch, disregarding the
instruction at address 1234.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="gbt">
<span id="debugger-command-gbt"></span><h2>gbt<a class="headerlink" href="#gbt" title="Link to this heading">¶</a></h2>
<p><strong>gbt [&lt;condition&gt;]</strong></p>
<p>Resumes execution.  Control will not be returned to the debugger until
a breakpoint or watchpoint is triggered, or until a conditional branch
or skip instruction is taken, following any delay slots.</p>
<p>The optional <strong>&lt;condition&gt;</strong> parameter lets you specify an expression
that will be evaluated each time a conditional branch is encountered.
If the result of the expression is true (non-zero), execution will be
halted after the branch if it is taken; otherwise, execution will
continue with no notification.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gbt</span></code></dt><dd><p>Resume execution until a breakpoint/watchpoint is triggered, or
until the next true branch.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gbt</span> <span class="pre">{pc</span> <span class="pre">!=</span> <span class="pre">1234}</span></code></dt><dd><p>Resume execution until the next true branch, disregarding the
instruction at address 1234.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="gex">
<span id="debugger-command-gex"></span><h2>gex<a class="headerlink" href="#gex" title="Link to this heading">¶</a></h2>
<p><strong>ge[x] [&lt;exception&gt;,[&lt;condition&gt;]]</strong></p>
<p>Resumes execution.  Control will not be returned to the debugger until
a breakpoint or watchpoint is triggered, or until an exception condition
is raised on the current CPU.  Use the optional <strong>&lt;exception&gt;</strong>
parameter to stop execution only for a specific exception condition.  If
<strong>&lt;exception&gt;</strong> is omitted, execution will stop for any exception
condition.</p>
<p>The optional <strong>&lt;condition&gt;</strong> parameter lets you specify an expression
that will be evaluated each time the specified exception condition
is raised.  If the result of the expression is true (non-zero), the
exception will halt execution; otherwise, execution will continue with
no notification.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gex</span></code></dt><dd><p>Resume execution until a breakpoint/watchpoint is triggered, or
until any exception condition is raised on the current CPU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ge</span> <span class="pre">2</span></code></dt><dd><p>Resume execution until a breakpoint/watchpoint is triggered, or
until exception condition 2 is raised on the current CPU.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="gint">
<span id="debugger-command-gint"></span><h2>gint<a class="headerlink" href="#gint" title="Link to this heading">¶</a></h2>
<p><strong>gi[nt] [&lt;irqline&gt;]</strong></p>
<p>Resumes execution.  Control will not be returned to the debugger until a
breakpoint or watchpoint is triggered, or until an interrupt is asserted
and acknowledged on the current CPU.  Use the optional <strong>&lt;irqline&gt;</strong>
parameter to stop execution only for a specific interrupt line being
asserted and acknowledged.  If <strong>&lt;irqline&gt;</strong> is omitted, execution will
stop when any interrupt is acknowledged.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gi</span></code></dt><dd><p>Resume execution until a breakpoint/watchpoint is triggered, or
any interrupt is asserted and acknowledged on the current CPU.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gint</span> <span class="pre">4</span></code></dt><dd><p>Resume execution until a breakpoint/watchpoint is triggered, or
interrupt request line 4 is asserted and acknowledged on the current
CPU.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="gni">
<span id="debugger-command-gni"></span><h2>gni<a class="headerlink" href="#gni" title="Link to this heading">¶</a></h2>
<p><strong>gni [&lt;count&gt;]</strong></p>
<p>Resumes execution.  Control will not be returned to the debugger until a
breakpoint or watchpoint is triggered.  A temporary unconditional breakpoint
is set at the program address <strong>&lt;count&gt;</strong> instructions sequentially past the
current one.  When this breakpoint is hit, it is automatically removed.</p>
<p>The <strong>&lt;count&gt;</strong> parameter is optional and defaults to 1 if omitted.  If
<strong>&lt;count&gt;</strong> is specified as zero, the command does nothing.  <strong>&lt;count&gt;</strong> is
not permitted to exceed 512 decimal.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gni</span></code></dt><dd><p>Resume execution until a breakpoint/watchpoint is triggered, including
the temporary breakpoint set at the address of the following instruction.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gni</span> <span class="pre">2</span></code></dt><dd><p>Resume execution until a breakpoint/watchpoint is triggered.  A temporary
breakpoint is set two instructions past the current one.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="gtime">
<span id="debugger-command-gtime"></span><h2>gtime<a class="headerlink" href="#gtime" title="Link to this heading">¶</a></h2>
<p><strong>gt[ime] &lt;milliseconds&gt;</strong></p>
<p>Resumes execution.  Control will not be returned to the debugger until a
specified interval of emulated time has elapsed.  The interval is
specified in milliseconds.</p>
<p>Example:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gtime</span> <span class="pre">#10000</span></code></dt><dd><p>Resume execution for ten seconds of emulated time.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="gvblank">
<span id="debugger-command-gvblank"></span><h2>gvblank<a class="headerlink" href="#gvblank" title="Link to this heading">¶</a></h2>
<p><strong>gv[blank]</strong></p>
<p>Resumes execution.  Control will not be returned to the debugger until a
breakpoint or watchpoint is triggered, or until the beginning of the
vertical blanking interval for an emulated screen.</p>
<p>Example:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">gv</span></code></dt><dd><p>Resume execution until a breakpoint/watchpoint is triggered, or a
vertical blanking interval starts.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="next">
<span id="debugger-command-next"></span><h2>next<a class="headerlink" href="#next" title="Link to this heading">¶</a></h2>
<p><strong>n[ext]</strong></p>
<p>Resumes execution until a different CPU is scheduled.  Execution will
not stop when a CPU is scheduled if it is ignored due to the use of
<a class="reference internal" href="#debugger-command-ignore"><span class="std std-ref">ignore</span></a> or <a class="reference internal" href="#debugger-command-focus"><span class="std std-ref">focus</span></a>.</p>
<p>Example:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code></dt><dd><p>Resume execution, stopping when a different CPU that is not ignored
is scheduled.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="focus">
<span id="debugger-command-focus"></span><h2>focus<a class="headerlink" href="#focus" title="Link to this heading">¶</a></h2>
<p><strong>focus &lt;CPU&gt;</strong></p>
<p>Focus exclusively on to the specified <strong>&lt;CPU&gt;</strong>, ignoring all other
CPUs.  The <strong>&lt;CPU&gt;</strong> argument can be a device tag or debugger CPU number
(see <a class="reference internal" href="index.html#debugger-devicespec"><span class="std std-ref">Specifying devices and address spaces</span></a> for details).  This is equivalent to
using the <a class="reference internal" href="#debugger-command-ignore"><span class="std std-ref">ignore</span></a> command to ignore all CPUs
besides the specified CPU.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">focus</span> <span class="pre">1</span></code></dt><dd><p>Focus exclusively on the second CPU in the system (zero-based
index), ignoring all other CPUs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">focus</span> <span class="pre">audiopcb:melodycpu</span></code></dt><dd><p>Focus exclusively on the CPU with the absolute tag path
<code class="docutils literal notranslate"><span class="pre">:audiopcb:melodycpu</span></code>.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="ignore">
<span id="debugger-command-ignore"></span><h2>ignore<a class="headerlink" href="#ignore" title="Link to this heading">¶</a></h2>
<p><strong>ignore [&lt;CPU&gt;[,&lt;CPU&gt;[,…]]]</strong></p>
<p>Ignores the specified CPUs in the debugger.  CPUs can be specified by
tag or debugger CPU number (see <a class="reference internal" href="index.html#debugger-devicespec"><span class="std std-ref">Specifying devices and address spaces</span></a> for details).
The debugger never shows execution for ignored CPUs, and breakpoints or
watchpoints on ignored CPUs have no effect.  If no CPUs are specified,
currently ignored CPUs will be listed.  Use the
<a class="reference internal" href="#debugger-command-observe"><span class="std std-ref">observe</span></a> command to stop ignoring a CPU.</p>
<p>Note that you cannot ignore all CPUs; at least CPU must be observed at
all times.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ignore</span> <span class="pre">audiocpu</span></code></dt><dd><p>Ignore the CPU with the absolute tag path <code class="docutils literal notranslate"><span class="pre">:audiocpu</span></code> when using
the debugger.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ignore</span> <span class="pre">2,3,4</span></code></dt><dd><p>Ignore the third, fourth and fifth CPUs in the system (zero-based
indices) when using the debugger.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ignore</span></code></dt><dd><p>List the CPUs that are currently being ignored by the debugger.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="observe">
<span id="debugger-command-observe"></span><h2>observe<a class="headerlink" href="#observe" title="Link to this heading">¶</a></h2>
<p><strong>observe [&lt;CPU&gt;[,&lt;CPU&gt;[,…]]]</strong></p>
<p>Allow interaction with the specified CPUs in the debugger.  CPUs can be
specified by tag or debugger CPU number (see <a class="reference internal" href="index.html#debugger-devicespec"><span class="std std-ref">Specifying devices and address spaces</span></a>
for details).  This command reverses the effects of the
<a class="reference internal" href="#debugger-command-ignore"><span class="std std-ref">ignore</span></a> command.  If no CPUs are specified,
currently observed CPUs will be listed.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">observe</span> <span class="pre">audiocpu</span></code></dt><dd><p>Stop ignoring the CPU with the absolute tag path <code class="docutils literal notranslate"><span class="pre">:audiocpu</span></code> when
using the debugger.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">observe</span> <span class="pre">2,3,4</span></code></dt><dd><p>Stop ignoring the third, fourth and fifth CPUs in the system
(zero-based indices) when using the debugger.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">observe</span></code></dt><dd><p>List the CPUs that are currently being observed by the debugger.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="trace">
<span id="debugger-command-trace"></span><h2>trace<a class="headerlink" href="#trace" title="Link to this heading">¶</a></h2>
<p><strong>trace {&lt;filename&gt;|off}[,&lt;CPU&gt;[,[noloop|logerror][,&lt;action&gt;]]]</strong></p>
<p>Starts or stops tracing for execution of the specified <strong>&lt;CPU&gt;</strong>, or the
currently visible CPU if no CPU is specified.  To enable tracing,
specify the trace log file name in the <strong>&lt;filename&gt;</strong> parameter.  To
disable tracing, use the keyword <code class="docutils literal notranslate"><span class="pre">off</span></code> for the <strong>&lt;filename&gt;</strong>
parameter.  If the <strong>&lt;filename&gt;</strong> argument begins with two right angle
brackets (<strong>&gt;&gt;</strong>), it is treated as a directive to open the file for
appending rather than overwriting.</p>
<p>The optional third parameter is a flags field.  The supported flags are
<code class="docutils literal notranslate"><span class="pre">noloop</span></code> and <code class="docutils literal notranslate"><span class="pre">logerror</span></code>.  Multiple flags must be separated by <code class="docutils literal notranslate"><span class="pre">|</span></code>
(pipe) characters.  By default, loops are detected and condensed to a
single line.  If the <code class="docutils literal notranslate"><span class="pre">noloop</span></code> flag is specified, loops will not be
detected and every instruction will be logged as executed.  If the
<code class="docutils literal notranslate"><span class="pre">logerror</span></code> flag is specified, error log output will be included in the
trace log.</p>
<p>The optional <strong>&lt;action&gt;</strong> parameter is a debugger command to execute
before each trace message is logged.  Generally, this will include a
<a class="reference internal" href="general.html#debugger-command-tracelog"><span class="std std-ref">tracelog</span></a> or <a class="reference internal" href="general.html#debugger-command-tracesym"><span class="std std-ref">tracesym</span></a>
command to include additional information in the trace log.  Note that
you may need to surround the action within braces <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">}</span></code> to ensure
commas and semicolons within the command are not interpreted in the
context of the <code class="docutils literal notranslate"><span class="pre">trace</span></code> command itself.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">trace</span> <span class="pre">joust.tr</span></code></dt><dd><p>Begin tracing the execution of the currently visible CPU, logging
output to the file <strong>joust.tr</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trace</span> <span class="pre">dribling.tr,maincpu</span></code></dt><dd><p>Begin tracing the execution of the CPU with the absolute tag path
<code class="docutils literal notranslate"><span class="pre">:maincpu:</span></code>, logging output to the file <strong>dribling.tr</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trace</span> <span class="pre">starswep.tr,,noloop</span></code></dt><dd><p>Begin tracing the execution of the currently visible CPU, logging
output to the file <strong>starswep.tr</strong>, with loop detection disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trace</span> <span class="pre">starswep.tr,1,logerror</span></code></dt><dd><p>Begin tracing the execution of the second CPU in the system
(zero-based index), logging output along with error log output to
the file <strong>starswep.tr</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trace</span> <span class="pre">starswep.tr,0,logerror|noloop</span></code></dt><dd><p>Begin tracing the execution of the first CPU in the system
(zero-based index), logging output along with error log output to
the file <strong>starswep.tr</strong>, with loop detection disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trace</span> <span class="pre">&gt;&gt;pigskin.tr</span></code></dt><dd><p>Begin tracing execution of the currently visible CPU, appending log
output to the file <strong>pigskin.tr</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trace</span> <span class="pre">off,0</span></code></dt><dd><p>Turn off tracing for the first CPU in the system (zero-based index).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">trace</span> <span class="pre">asteroid.tr,,,{tracelog</span> <span class="pre">&quot;A=%02X</span> <span class="pre">&quot;,a}</span></code></dt><dd><p>Begin tracing the execution of the currently visible CPU, logging
output to the file <strong>asteroid.tr</strong>.  Before each line, output
<strong>A=&lt;aval&gt;</strong> to the trace log.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="traceover">
<span id="debugger-command-traceover"></span><h2>traceover<a class="headerlink" href="#traceover" title="Link to this heading">¶</a></h2>
<p><strong>traceover {&lt;filename&gt;|off}[,&lt;CPU&gt;[,[noloop|logerror][,&lt;action&gt;]]]</strong></p>
<p>Starts or stops tracing for execution of the specified <strong>&lt;CPU&gt;</strong>, or the
currently visible CPU if no CPU is specified.  When a subroutine call is
encountered, tracing will skip over the subroutine.  The same algorithm
is used as is used in the <a class="reference internal" href="#debugger-command-over"><span class="std std-ref">step over</span></a>
command.  It will not work properly with recursive functions, or if the
return address does not immediately follow the call instruction.</p>
<p>This command accepts the same parameters as the
<a class="reference internal" href="#debugger-command-trace"><span class="std std-ref">trace</span></a> command.  Please refer to the
corresponding section for a detailed description of options and more
examples.</p>
<p>Examples:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">traceover</span> <span class="pre">joust.tr</span></code></dt><dd><p>Begin tracing the execution of the currently visible CPU, logging
output to the file <strong>joust.tr</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">traceover</span> <span class="pre">dribling.tr,maincpu</span></code></dt><dd><p>Begin tracing the execution of the CPU with the absolute tag path
<code class="docutils literal notranslate"><span class="pre">:maincpu:</span></code>, logging output to the file <strong>dribling.tr</strong>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">traceover</span> <span class="pre">starswep.tr,,noloop</span></code></dt><dd><p>Begin tracing the execution of the currently visible CPU, logging
output to the file <strong>starswep.tr</strong>, with loop detection disabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">traceover</span> <span class="pre">off,0</span></code></dt><dd><p>Turn off tracing for the first CPU in the system (zero-based index).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">traceover</span> <span class="pre">asteroid.tr,,,{tracelog</span> <span class="pre">&quot;A=%02X</span> <span class="pre">&quot;,a}</span></code></dt><dd><p>Begin tracing the execution of the currently visible CPU, logging
output to the file <strong>asteroid.tr</strong>.  Before each line, output
<strong>A=&lt;aval&gt;</strong> to the trace log.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
<section id="traceflush">
<span id="debugger-command-traceflush"></span><h2>traceflush<a class="headerlink" href="#traceflush" title="Link to this heading">¶</a></h2>
<p><strong>traceflush</strong></p>
<p>Flushes all open trace log files to disk.</p>
<p>Example:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">traceflush</span></code></dt><dd><p>Flush trace log files.</p>
</dd>
</dl>
<p>Back to <a class="reference internal" href="#debugger-execution-list"><span class="std std-ref">Execution Debugger Commands</span></a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="memory.html" class="btn btn-neutral float-left" title="Memory Debugger Commands" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="breakpoint.html" class="btn btn-neutral float-right" title="Breakpoint Debugger Commands" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1997-2025, MAMEdev and contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>