<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CPU devices &mdash; MAME Documentation 0.277 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/documentation_options.js?v=561e49e2"></script>
        <script src="../_static/doctools.js?v=9bcbadda"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The new floppy subsystem" href="floppy.html" />
    <link rel="prev" title="Emulated system memory and address spaces management" href="memory.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MAME Documentation
          </a>
              <div class="version">
                0.277
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../whatis.html">What is MAME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../healthwarning.html">Health Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../initialsetup/index.html">Getting MAME prepared</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingmame/index.html">Basic MAME Usage and Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../commandline/index.html">MAME Command-line Usage and OS-Specific Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plugins/index.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/index.html">Advanced configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debugger/index.html">MAME Debugger</a></li>
<li class="toctree-l1"><a class="reference internal" href="../luascript/index.html">Lua Scripting Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">MAME External Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributing to MAME</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Technical Specifications</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="naming.html">MAME Naming Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="layout_files.html">MAME Layout Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="layout_script.html">MAME Layout Scripting</a></li>
<li class="toctree-l2"><a class="reference internal" href="object_finders.html">Object Finders</a></li>
<li class="toctree-l2"><a class="reference internal" href="inputsystem.html">Input System</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_memory_interface.html">The device_memory_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_rom_interface.html">The device_rom_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_disasm_interface.html">The device_disasm_interface and the disassemblers</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory.html">Emulated system memory and address spaces management</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">CPU devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="floppy.html">The new floppy subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="nscsi.html">The new SCSI subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="m6502.html">The new 6502 family implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="uml_instructions.html">UML Instruction Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="poly_manager.html">Software 3D Rendering in MAME</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security.html">MAME and security concerns</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">The MAME License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MAME Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Technical Specifications</a></li>
      <li class="breadcrumb-item active">CPU devices</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="cpu-devices">
<h1>CPU devices<a class="headerlink" href="#cpu-devices" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id1">1. Overview</a></p></li>
<li><p><a class="reference internal" href="#drc" id="id2">2. DRC</a></p></li>
<li><p><a class="reference internal" href="#interruptibility" id="id3">3. Interruptibility</a></p>
<ul>
<li><p><a class="reference internal" href="#definition" id="id4">3.1 Definition</a></p></li>
<li><p><a class="reference internal" href="#implementation-requirements" id="id5">3.2 Implementation requirements</a></p></li>
<li><p><a class="reference internal" href="#example-implementation-with-generators" id="id6">3.3 Example implementation with generators</a></p></li>
<li><p><a class="reference internal" href="#bus-contention-cpu-device-interface" id="id7">3.4 Bus contention cpu_device interface</a></p></li>
<li><p><a class="reference internal" href="#interaction-with-drc" id="id8">3.5 Interaction with DRC</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="overview">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">1. Overview</a><a class="headerlink" href="#overview" title="Link to this heading">¶</a></h2>
<p>CPU devices derivatives are used, unsurprisingly, to implement the
emulation of CPUs, MCUs and SOCs.  A CPU device is first a combination
of <code class="docutils literal notranslate"><span class="pre">device_execute_interface</span></code>, <code class="docutils literal notranslate"><span class="pre">device_memory_interface</span></code>,
<code class="docutils literal notranslate"><span class="pre">device_state_interface</span></code> and <code class="docutils literal notranslate"><span class="pre">device_disasm_interface</span></code>.  Refer to
the associated documentations when they exist.</p>
<p>Two more functionalities are specific to CPU devices which are the DRC
and the interruptibility support.</p>
</section>
<section id="drc">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">2. DRC</a><a class="headerlink" href="#drc" title="Link to this heading">¶</a></h2>
<p>TODO.</p>
</section>
<section id="interruptibility">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">3. Interruptibility</a><a class="headerlink" href="#interruptibility" title="Link to this heading">¶</a></h2>
<section id="definition">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">3.1 Definition</a><a class="headerlink" href="#definition" title="Link to this heading">¶</a></h3>
<p>An interruptible CPU is defined as a core which is able to suspend the
execution of one instruction at any time, exit execute_run, then at
the next call of <code class="docutils literal notranslate"><span class="pre">execute_run</span></code> keep going from where it was.  This
includes being able to abort an issued memory access, quit
execute_run, then upon the next call of execute_run reissue the exact
same access.</p>
</section>
<section id="implementation-requirements">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">3.2 Implementation requirements</a><a class="headerlink" href="#implementation-requirements" title="Link to this heading">¶</a></h3>
<p>Memory accesses must be done with <code class="docutils literal notranslate"><span class="pre">read_interruptible</span></code> or
<code class="docutils literal notranslate"><span class="pre">write_interruptible</span></code> on a <code class="docutils literal notranslate"><span class="pre">memory_access_specific</span></code> or a
<code class="docutils literal notranslate"><span class="pre">memory_access_cache</span></code>.  The access must be done as bus width and bus
alignment.</p>
<p>After each access the core must test whether <code class="docutils literal notranslate"><span class="pre">icount</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code>.  This
test should be done after <code class="docutils literal notranslate"><span class="pre">icount</span></code> is decremented of the time taken
by the access itself, to limit the number of tests.  When <code class="docutils literal notranslate"><span class="pre">icount</span></code>
reaches 0 or less it means that the instruction emulation needs to be
suspended.</p>
<p>To know whether the access needs to be re-issued,
<code class="docutils literal notranslate"><span class="pre">access_to_be_redone()</span></code> needs to be called.  If it returns true then
the time taken by the access needs to be credited back, since it
hasn't yet happened, and the access will need to be re-issued.  The
call to <code class="docutils literal notranslate"><span class="pre">access_to_be_redone()</span></code> clears the reissue flag.  If you
need to check the flag without clearing it use
<code class="docutils literal notranslate"><span class="pre">access_to_be_redone_noclear()</span></code>.</p>
<p>The core needs to do enough bookkeeping to eventually restart the
instruction execution just before the access or just after the test,
depending on the need of reissue.</p>
<p>Finally, to indicate to the rest of the infrastructure the support, it
must override cpu_is_interruptible() to return true.</p>
</section>
<section id="example-implementation-with-generators">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">3.3 Example implementation with generators</a><a class="headerlink" href="#example-implementation-with-generators" title="Link to this heading">¶</a></h3>
<p>To ensure decent performance, the current implementations (h8, 6502
and 68000) use a python generator to generate two versions of each
instruction interpreter, one for the normal emulation, and one for
restarting the instruction.</p>
<p>The restarted version looks like that (for a 4-cycles per access cpu):</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">device::execute_inst_restarted</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="p">(</span><span class="n">m_inst_substate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">        </span><span class="p">[...]</span>

<span class="w">        </span><span class="n">m_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...];</span>
<span class="w">        </span><span class="n">m_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...];</span>
<span class="w">        </span><span class="p">[[</span><span class="n">fallthrough</span><span class="p">]];</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">42</span><span class="p">:</span>
<span class="w">        </span><span class="n">m_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">specific</span><span class="p">.</span><span class="n">read_interruptible</span><span class="p">(</span><span class="n">m_address</span><span class="p">,</span><span class="w"> </span><span class="n">m_mask</span><span class="p">);</span>
<span class="w">        </span><span class="n">m_icount</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">m_icount</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">access_to_be_redone</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">m_icount</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">                </span><span class="n">m_inst_substate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span>
<span class="w">                </span><span class="n">m_inst_substate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">43</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="p">[[</span><span class="n">fallthrough</span><span class="p">]];</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">43</span><span class="p">:</span>
<span class="w">        </span><span class="p">[...]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_result</span><span class="p">;</span>
<span class="w">        </span><span class="p">[...]</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">m_inst_substate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The non-restarted version is the same thing with the switch and the
final <code class="docutils literal notranslate"><span class="pre">m_inst_substate</span></code> clearing removed.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">device::execute_inst_non_restarted</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">[...]</span>
<span class="w">    </span><span class="n">m_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...];</span>
<span class="w">    </span><span class="n">m_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...];</span>
<span class="w">    </span><span class="n">m_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">specific</span><span class="p">.</span><span class="n">read_interruptible</span><span class="p">(</span><span class="n">m_address</span><span class="p">,</span><span class="w"> </span><span class="n">m_mask</span><span class="p">);</span>
<span class="w">    </span><span class="n">m_icount</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">m_icount</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">access_to_be_redone</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">m_icount</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">            </span><span class="n">m_inst_substate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span>
<span class="w">            </span><span class="n">m_inst_substate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">43</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">[...]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_result</span><span class="p">;</span>
<span class="w">    </span><span class="p">[...]</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The main loop then looks like this:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">device::execute_run</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">m_inst_substate</span><span class="p">)</span>
<span class="w">        </span><span class="n">call</span><span class="w"> </span><span class="n">appropriate</span><span class="w"> </span><span class="n">restarted</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">handler</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">m_icount</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">debugger_instruction_hook</span><span class="p">(</span><span class="n">m_pc</span><span class="p">);</span>
<span class="w">        </span><span class="n">call</span><span class="w"> </span><span class="n">appropriate</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">restarted</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">handler</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The idea is thus that <code class="docutils literal notranslate"><span class="pre">m_inst_substate</span></code> indicates where in an
instruction one is, but only when an interruption happens.  It
otherwise stays at 0 and is essentially never looked at.  Having two
versions of the interpretation allows to remove the overhead of the
switch and the end-of-instruction substate clearing.</p>
<p>It is not a requirement to use a generator-based that method, but a
different one which does not have unacceptable performance
implications has not yet been found.</p>
</section>
<section id="bus-contention-cpu-device-interface">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">3.4 Bus contention cpu_device interface</a><a class="headerlink" href="#bus-contention-cpu-device-interface" title="Link to this heading">¶</a></h3>
<p>The main way to setup bus contention is through the memory maps.
Lower-level access can be obtained through some methods on cpu_device
though.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">cpu_device::access_before_time</span><span class="p">(</span><span class="n">u64</span><span class="w"> </span><span class="n">access_time</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="w"> </span><span class="n">current_time</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">access_before_time</span></code> allows to try to run an access at a
given time in cpu cycles.  It takes the current time
(<code class="docutils literal notranslate"><span class="pre">total_cycles()</span></code>) and the expected time for the access.  If there
aren't enough cycles to reach that time the remaining cycles are eaten
and the method returns true to tell not to do the access and call the
method again eventually.  Otherwise enough cycles are eaten to reach
the access time and false is returned to tell to do the access.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">cpu_device::access_before_delay</span><span class="p">(</span><span class="n">u32</span><span class="w"> </span><span class="n">cycles</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">access_before_delay</span></code> allows to try to run an access
after a given delay.  The tag is an opaque, non-nullptr value used to
characterize the source of the delay, so that the delay is not applied
multiple times.  Similarly to the previous method cycles are eaten and
true is returned to abort the access, false to execute it.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">cpu_device::access_after_delay</span><span class="p">(</span><span class="n">u32</span><span class="w"> </span><span class="n">cycles</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">access_after_delay</span></code> allows to add a delay after an
access is done.  There is no abort possible, hence no return boolean.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">cpu_device::defer_access</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">defer_access</span></code> tells the cpu that we need to wait for an
external event.  It marks the access as to be redone, and eats all the
remaining cycles of the timeslice.  The idea is then that the access
will be retried after time advances up to the next global system
synchronisation event (sync, timer timeout or set_input_line).  This
is the method to use when for instance waiting on a magic latch for
data expected from scsi transfers, which happen on timer timeouts.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">cpu_device::retry_access</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="p">;</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">retry_access</span></code> tells the cpu that the access will need to
be retried, and nothing else.  This can easily reach a situation of
livelock, so be careful.  It is used for instance to simulate a wait
line (for the z80 for instance) which is controlled through
set_input_line.  The idea is that the device setting wait does the
set_input_line and a retry_access.  The cpu core, as long as the wait
line is set just eats cycles.  Then, when the line is cleared the core
will retry the access.</p>
</section>
<section id="interaction-with-drc">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">3.5 Interaction with DRC</a><a class="headerlink" href="#interaction-with-drc" title="Link to this heading">¶</a></h3>
<p>At this point, interruptibility and DRC are entirely incompatible.  We
do not have a method to quit the generated code before or after an
access.  It's theorically possible but definitely non-trivial.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="memory.html" class="btn btn-neutral float-left" title="Emulated system memory and address spaces management" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="floppy.html" class="btn btn-neutral float-right" title="The new floppy subsystem" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1997-2025, MAMEdev and contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>