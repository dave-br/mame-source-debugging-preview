<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Emulated system memory and address spaces management &mdash; MAME Documentation 0.280 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/documentation_options.js?v=e8156010"></script>
        <script src="../_static/doctools.js?v=9bcbadda"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="CPU devices" href="cpu_device.html" />
    <link rel="prev" title="The device_sound_interface" href="device_sound_interface.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MAME Documentation
          </a>
              <div class="version">
                0.280
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../whatis.html">What is MAME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../healthwarning.html">Health Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../initialsetup/index.html">Getting MAME prepared</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingmame/index.html">Basic MAME Usage and Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../commandline/index.html">MAME Command-line Usage and OS-Specific Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plugins/index.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/index.html">Advanced configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debugger/index.html">MAME Debugger</a></li>
<li class="toctree-l1"><a class="reference internal" href="../luascript/index.html">Lua Scripting Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">MAME External Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributing to MAME</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Technical Specifications</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="naming.html">MAME Naming Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="layout_files.html">MAME Layout Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="layout_script.html">MAME Layout Scripting</a></li>
<li class="toctree-l2"><a class="reference internal" href="object_finders.html">Object Finders</a></li>
<li class="toctree-l2"><a class="reference internal" href="inputsystem.html">Input System</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_memory_interface.html">The device_memory_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_rom_interface.html">The device_rom_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_disasm_interface.html">The device_disasm_interface and the disassemblers</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_sound_interface.html">The device_sound_interface</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Emulated system memory and address spaces management</a></li>
<li class="toctree-l2"><a class="reference internal" href="cpu_device.html">CPU devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="floppy.html">The new floppy subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="nscsi.html">The new SCSI subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="m6502.html">The new 6502 family implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="uml_instructions.html">UML Instruction Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="poly_manager.html">Software 3D Rendering in MAME</a></li>
<li class="toctree-l2"><a class="reference internal" href="audio_effects.html">Audio effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="osd_audio.html">OSD audio support</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security.html">MAME and security concerns</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">The MAME License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MAME Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Technical Specifications</a></li>
      <li class="breadcrumb-item active">Emulated system memory and address spaces management</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="emulated-system-memory-and-address-spaces-management">
<h1>Emulated system memory and address spaces management<a class="headerlink" href="#emulated-system-memory-and-address-spaces-management" title="Link to this heading">Â¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id4">1. Overview</a></p></li>
<li><p><a class="reference internal" href="#basic-concepts" id="id5">2. Basic concepts</a></p>
<ul>
<li><p><a class="reference internal" href="#address-spaces" id="id6">2.1 Address spaces</a></p></li>
<li><p><a class="reference internal" href="#address-maps" id="id7">2.2 Address maps</a></p></li>
<li><p><a class="reference internal" href="#shares-banks-and-regions" id="id8">2.3 Shares, banks and regions</a></p></li>
<li><p><a class="reference internal" href="#views" id="id9">2.4 Views</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#memory-objects" id="id10">3. Memory objects</a></p>
<ul>
<li><p><a class="reference internal" href="#shares-memory-share" id="id11">3.1 Shares - memory_share</a></p></li>
<li><p><a class="reference internal" href="#banks-memory-bank" id="id12">3.2 Banks - memory_bank</a></p></li>
<li><p><a class="reference internal" href="#regions-memory-region" id="id13">3.3 Regions - memory_region</a></p></li>
<li><p><a class="reference internal" href="#views-memory-view" id="id14">3.4 Views - memory_view</a></p></li>
<li><p><a class="reference internal" href="#bus-contention-handling" id="id15">3.5 Bus contention handling</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#address-maps-api" id="id16">4. Address maps API</a></p>
<ul>
<li><p><a class="reference internal" href="#general-api-structure" id="id17">4.1 General API structure</a></p></li>
<li><p><a class="reference internal" href="#global-configurations" id="id18">4.2 Global configurations</a></p>
<ul>
<li><p><a class="reference internal" href="#global-masking" id="id19">4.2.1 Global masking</a></p></li>
<li><p><a class="reference internal" href="#returned-value-on-unmapped-nop-ed-read" id="id20">4.2.2 Returned value on unmapped/nop-ed read</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#handler-setting" id="id21">4.3 Handler setting</a></p>
<ul>
<li><p><a class="reference internal" href="#method-on-the-current-device" id="id22">4.3.1 Method on the current device</a></p></li>
<li><p><a class="reference internal" href="#method-on-a-different-device" id="id23">4.3.2 Method on a different device</a></p></li>
<li><p><a class="reference internal" href="#lambda-function" id="id24">4.3.3 Lambda function</a></p></li>
<li><p><a class="reference internal" href="#direct-memory-access" id="id25">4.3.4 Direct memory access</a></p></li>
<li><p><a class="reference internal" href="#bank-access" id="id26">4.3.5 Bank access</a></p></li>
<li><p><a class="reference internal" href="#port-access" id="id27">4.3.6 Port access</a></p></li>
<li><p><a class="reference internal" href="#dropped-access" id="id28">4.3.7 Dropped access</a></p></li>
<li><p><a class="reference internal" href="#unmapped-access" id="id29">4.3.8 Unmapped access</a></p></li>
<li><p><a class="reference internal" href="#subdevice-mapping" id="id30">4.3.9 Subdevice mapping</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#range-qualifiers" id="id31">4.4 Range qualifiers</a></p>
<ul>
<li><p><a class="reference internal" href="#mirroring" id="id32">4.4.1 Mirroring</a></p></li>
<li><p><a class="reference internal" href="#masking" id="id33">4.4.2 Masking</a></p></li>
<li><p><a class="reference internal" href="#selection" id="id34">4.4.3 Selection</a></p></li>
<li><p><a class="reference internal" href="#sub-unit-selection" id="id35">4.4.4 Sub-unit selection</a></p></li>
<li><p><a class="reference internal" href="#chip-select-handling-on-sub-unit" id="id36">4.4.5 Chip select handling on sub-unit</a></p></li>
<li><p><a class="reference internal" href="#user-flags" id="id37">4.4.6 User flags</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#contention" id="id38">4.5 Contention</a></p></li>
<li><p><a class="reference internal" href="#view-setup" id="id39">4.6 View setup</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#address-space-dynamic-mapping-api" id="id40">5. Address space dynamic mapping API</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id41">5.1 General API structure</a></p></li>
<li><p><a class="reference internal" href="#handler-mapping" id="id42">5.2 Handler mapping</a></p></li>
<li><p><a class="reference internal" href="#direct-memory-range-mapping" id="id43">5.3 Direct memory range mapping</a></p></li>
<li><p><a class="reference internal" href="#bank-mapping" id="id44">5.4 Bank mapping</a></p></li>
<li><p><a class="reference internal" href="#port-mapping" id="id45">5.5 Port mapping</a></p></li>
<li><p><a class="reference internal" href="#dropped-accesses" id="id46">5.6 Dropped accesses</a></p></li>
<li><p><a class="reference internal" href="#unmapped-accesses" id="id47">5.7 Unmapped accesses</a></p></li>
<li><p><a class="reference internal" href="#device-map-installation" id="id48">5.8 Device map installation</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id49">5.9 Contention</a></p></li>
<li><p><a class="reference internal" href="#view-installation" id="id50">5.10 View installation</a></p></li>
<li><p><a class="reference internal" href="#taps" id="id51">5.11 Taps</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="overview">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">1. Overview</a><a class="headerlink" href="#overview" title="Link to this heading">Â¶</a></h2>
<p>The memory subsystem (emumem and addrmap) combines multiple functions
useful for system emulation:</p>
<ul class="simple">
<li><p>address bus decoding and dispatching with caching</p></li>
<li><p>static descriptions of an address map</p></li>
<li><p>RAM allocation and registration for state saving</p></li>
<li><p>interaction with memory regions to access ROM</p></li>
</ul>
<p>Devices create address spaces, e.g. decodable buses, through the
<code class="docutils literal notranslate"><span class="pre">device_memory_interface</span></code>.  The machine configuration sets up address
maps to put in the address spaces, then the device can do read and
writes through the bus.</p>
</section>
<section id="basic-concepts">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">2. Basic concepts</a><a class="headerlink" href="#basic-concepts" title="Link to this heading">Â¶</a></h2>
<section id="address-spaces">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">2.1 Address spaces</a><a class="headerlink" href="#address-spaces" title="Link to this heading">Â¶</a></h3>
<p>An address space, implemented in the class <strong>address_space</strong>,
represents an addressable bus with potentially multiple sub-devices
connected requiring a decode.  It has a number of data lines (8, 16,
32 or 64) called data width, a number of address lines (1 to 32)
called address width and an Endianness.  In addition an address shift
allows for buses that have an atomic granularity different than a
byte.</p>
<p>Address space objects provide a series of methods for read and write
access, and a second series of methods for dynamically changing the
decode.</p>
</section>
<section id="address-maps">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">2.2 Address maps</a><a class="headerlink" href="#address-maps" title="Link to this heading">Â¶</a></h3>
<p>An address map is a static description of the decode expected when
using a bus.  It connects to memory, other devices and methods, and is
installed, usually at startup, in an address space.  That description
is stored in an <strong>address_map</strong> structure which is filled
programmatically.</p>
</section>
<section id="shares-banks-and-regions">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">2.3 Shares, banks and regions</a><a class="headerlink" href="#shares-banks-and-regions" title="Link to this heading">Â¶</a></h3>
<p>Memory shares are allocated memory zones that can be put in multiple
places in the same or different address spaces, and can also be
directly accessed from devices.</p>
<p>Memory banks are zones that indirect memory access, giving the
possibility to dynamically and efficiently change where a zone
actually points to.</p>
<p>Memory regions are read-only memory zones in which ROMs are loaded.</p>
<p>All of these have names allowing to access them.</p>
</section>
<section id="views">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">2.4 Views</a><a class="headerlink" href="#views" title="Link to this heading">Â¶</a></h3>
<p>Views are a way to multiplex different submaps over a memory range
with fast switching.  It is to be used when multiple devices map at
the same addresses and are switched in externally.  They must be
created as an object of the device and then setup either statically in
a memory map or dynamically through <code class="docutils literal notranslate"><span class="pre">install_*</span></code> calls.</p>
<p>Switchable submaps, aka variants, are named through an integer.  An
internal indirection through a map ensures that any integer value can
be used.</p>
</section>
</section>
<section id="memory-objects">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">3. Memory objects</a><a class="headerlink" href="#memory-objects" title="Link to this heading">Â¶</a></h2>
<section id="shares-memory-share">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">3.1 Shares - memory_share</a><a class="headerlink" href="#shares-memory-share" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">memory_share</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">ptr</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">bytes</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">endianness_t</span><span class="w"> </span><span class="nf">endianness</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="nf">bitwidth</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="nf">bytewidth</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A memory share is a named allocated memory zone that is automatically
saved in save states and can be mapped in address spaces.  It is the
standard container for memory that is shared between spaces, but also
shared between an emulated CPU and a driver.  As such one has easy
access to its contents from the driver class.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">required_shared_ptr</span><span class="o">&lt;</span><span class="n">uNN</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_share_ptr</span><span class="p">;</span>
<span class="n">optional_shared_ptr</span><span class="o">&lt;</span><span class="n">uNN</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_share_ptr</span><span class="p">;</span>
<span class="n">required_shared_ptr_array</span><span class="o">&lt;</span><span class="n">uNN</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_share_ptr_array</span><span class="p">;</span>
<span class="n">optional_shared_ptr_array</span><span class="o">&lt;</span><span class="n">uNN</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_share_ptr_array</span><span class="p">;</span>

<span class="p">[</span><span class="n">device</span><span class="w"> </span><span class="n">constructor</span><span class="p">]</span><span class="w"> </span><span class="n">m_share_ptr</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name&quot;</span><span class="p">),</span>
<span class="p">[</span><span class="n">device</span><span class="w"> </span><span class="n">constructor</span><span class="p">]</span><span class="w"> </span><span class="n">m_share_ptr_array</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name%u&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0U</span><span class="p">),</span>
</pre></div>
</div>
<p>At the device level, a pointer to the memory zone can easily be
retrieved by building one of these four finders.  Note that like for
every finder calling <code class="docutils literal notranslate"><span class="pre">target()</span></code> on the finder gives you the base
pointer of the <code class="docutils literal notranslate"><span class="pre">memory_share</span></code> object.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">memory_share_creator</span><span class="o">&lt;</span><span class="n">uNN</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_share</span><span class="p">;</span>

<span class="p">[</span><span class="n">device</span><span class="w"> </span><span class="n">constructor</span><span class="p">]</span><span class="w"> </span><span class="n">m_share</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">endianness</span><span class="p">),</span>
</pre></div>
</div>
<p>A memory share can be created if it doesnât exist in a memory map
through that creator class.  If it already exists it is just
retrieved.  That class behaves like a pointer but also has the
<code class="docutils literal notranslate"><span class="pre">target()</span></code>, <code class="docutils literal notranslate"><span class="pre">length()</span></code>, <code class="docutils literal notranslate"><span class="pre">bytes()</span></code>, <code class="docutils literal notranslate"><span class="pre">endianness()</span></code>,
<code class="docutils literal notranslate"><span class="pre">bitwidth()</span></code> and <code class="docutils literal notranslate"><span class="pre">bytewidth()</span></code> methods for share information.  The
desired size is specified in bytes.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">memory_share</span><span class="w"> </span><span class="o">*</span><span class="nf">memshare</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">memshare</span></code> device method retrieves a memory share by name.  Beware
that the lookup can be expensive, prefer finders instead.</p>
</section>
<section id="banks-memory-bank">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">3.2 Banks - memory_bank</a><a class="headerlink" href="#banks-memory-bank" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">memory_bank</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">tag</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">entry</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_entry</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">entrynum</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">configure_entry</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">entrynum</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">configure_entries</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">startentry</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numentry</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">stride</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_base</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">base</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">base</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A memory bank is a named memory zone indirection that can be mapped in
address spaces.  It points to <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> when created.
<code class="docutils literal notranslate"><span class="pre">configure_entry</span></code> associates an entry number and a base pointer.
<code class="docutils literal notranslate"><span class="pre">configure_entries</span></code> does the same for multiple consecutive entries
spanning a memory zone.</p>
<p><code class="docutils literal notranslate"><span class="pre">set_base</span></code> sets the base address for the active entry.  If there are
no entries, entry 0 (zero) is automatically created and selected.  Use
of <code class="docutils literal notranslate"><span class="pre">set_base</span></code> should be avoided in favour of pre-configured entries
unless there are an impractically large number of possible base
addresses.</p>
<p><code class="docutils literal notranslate"><span class="pre">set_entry</span></code> dynamically and efficiently selects the active entry,
<code class="docutils literal notranslate"><span class="pre">entry()</span></code> returns the active entry number, and <code class="docutils literal notranslate"><span class="pre">base()</span></code> gets the
associated base pointer.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">required_memory_bank</span><span class="w"> </span><span class="n">m_bank</span><span class="p">;</span>
<span class="n">optional_memory_bank</span><span class="w"> </span><span class="n">m_bank</span><span class="p">;</span>
<span class="n">required_memory_bank_array</span><span class="o">&lt;</span><span class="n">count</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_bank_array</span><span class="p">;</span>
<span class="n">optional_memory_bank_array</span><span class="o">&lt;</span><span class="n">count</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_bank_array</span><span class="p">;</span>

<span class="p">[</span><span class="n">device</span><span class="w"> </span><span class="n">constructor</span><span class="p">]</span><span class="w"> </span><span class="n">m_bank</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name&quot;</span><span class="p">),</span>
<span class="p">[</span><span class="n">device</span><span class="w"> </span><span class="n">constructor</span><span class="p">]</span><span class="w"> </span><span class="n">m_bank_array</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name%u&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0U</span><span class="p">),</span>
</pre></div>
</div>
<p>At the device level, a pointer to the memory bank object can easily be
retrieved by building one of these four finders.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">memory_bank_creator</span><span class="w"> </span><span class="n">m_bank</span><span class="p">;</span>

<span class="p">[</span><span class="n">device</span><span class="w"> </span><span class="n">constructor</span><span class="p">]</span><span class="w"> </span><span class="n">m_bank</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name&quot;</span><span class="p">),</span>
</pre></div>
</div>
<p>A memory bank can be created if it doesnât exist in a memory map
through that creator class.  If it already exists it is just
retrieved.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">memory_bank</span><span class="w"> </span><span class="o">*</span><span class="nf">membank</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">membank</span></code> device method retrieves a memory bank by name.  Beware
that the lookup can be expensive, prefer finders instead.</p>
</section>
<section id="regions-memory-region">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">3.3 Regions - memory_region</a><a class="headerlink" href="#regions-memory-region" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">memory_region</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="nf">base</span><span class="p">();</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="nf">end</span><span class="p">();</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="nf">bytes</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">endianness_t</span><span class="w"> </span><span class="nf">endianness</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="nf">bitwidth</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="nf">bytewidth</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">as_u8</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">u16</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">as_u16</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">as_u32</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">as_u64</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A region is used to store read-only data like ROMs or the result of
fixed decryptions.  Their contents are not saved, which is why they
should not being written to from the emulated system.  They donât
really have an intrinsic width (<code class="docutils literal notranslate"><span class="pre">base()</span></code> returns an <code class="docutils literal notranslate"><span class="pre">u8</span> <span class="pre">*</span></code> always),
which is historical and pretty much unfixable at this point.  The
<code class="docutils literal notranslate"><span class="pre">as_*</span></code> methods allow for accessing them at a given width.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">required_memory_region</span><span class="w"> </span><span class="n">m_region</span><span class="p">;</span>
<span class="n">optional_memory_region</span><span class="w"> </span><span class="n">m_region</span><span class="p">;</span>
<span class="n">required_memory_region_array</span><span class="o">&lt;</span><span class="n">count</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_region_array</span><span class="p">;</span>
<span class="n">optional_memory_region_array</span><span class="o">&lt;</span><span class="n">count</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_region_array</span><span class="p">;</span>

<span class="p">[</span><span class="n">device</span><span class="w"> </span><span class="n">constructor</span><span class="p">]</span><span class="w"> </span><span class="n">m_region</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name&quot;</span><span class="p">),</span>
<span class="p">[</span><span class="n">device</span><span class="w"> </span><span class="n">constructor</span><span class="p">]</span><span class="w"> </span><span class="n">m_region_array</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name%u&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0U</span><span class="p">),</span>
</pre></div>
</div>
<p>At the device level, a pointer to the memory region object can easily be
retrieved by building one of these four finders.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">memory_region</span><span class="w"> </span><span class="o">*</span><span class="nf">memregion</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">tag</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">memregion</span></code> device method retrieves a memory region by name.
Beware that the lookup can be expensive, prefer finders instead.</p>
</section>
<section id="views-memory-view">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">3.4 Views - memory_view</a><a class="headerlink" href="#views-memory-view" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">memory_view</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">memory_view</span><span class="p">(</span><span class="n">device_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="n">memory_view_entry</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">slot</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">select</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">entry</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">disable</span><span class="p">();</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A view allows to switch part of a memory map between multiple
possibilities, or even disable it entirely to see what was there
before.  It is created as an object of the device.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">memory_view</span><span class="w"> </span><span class="n">m_view</span><span class="p">;</span>

<span class="p">[</span><span class="n">device</span><span class="w"> </span><span class="n">constructor</span><span class="p">]</span><span class="w"> </span><span class="n">m_view</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name&quot;</span><span class="p">),</span>
</pre></div>
</div>
<p>It is then setup through the address map API or dynamically.  At
runtime, a numbered variant can be selected using the <code class="docutils literal notranslate"><span class="pre">select</span></code> method,
or the view can be disabled using the <code class="docutils literal notranslate"><span class="pre">disable</span></code> method.  A disabled
view can be re-enabled at any time.</p>
</section>
<section id="bus-contention-handling">
<span id="id1"></span><h3><a class="toc-backref" href="#id15" role="doc-backlink">3.5 Bus contention handling</a><a class="headerlink" href="#bus-contention-handling" title="Link to this heading">Â¶</a></h3>
<p>Some specific CPUs have been upgraded to be interruptible which allows
to add bus contention and wait states capabitilites.  Being
interruptible means, in practice, that an instruction can be
interrupted at any time and the execute_run method of the core exited.
Other devices can then run, then eventually controls returns to the
core and the instruction continues from the point it was started.
Importantly, this can be triggered from a handler and even be used to
interrupt just before the access that is currently done
(e.g. continuation will redo the access).</p>
<p>The CPUs supporting that declare their capability by overriding the
method <code class="docutils literal notranslate"><span class="pre">cpu_is_interruptible</span></code> to return true.</p>
<p>Three intermediate contention handlers can be added to accesses:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">before_delay</span></code>: wait a number of cycles before doing the access.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">after_delay</span></code>: wait a number of cycles after doing the access.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">before_time</span></code>: wait for a given time before doing the access.</p></li>
</ul>
<p>For the delay handlers, a method or lambda is called which returns the
number of cycles to wait (as a u32).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">before_time</span></code> is special.  First, the time is compared to the
current value of cpu-&gt;total_cycles().  That value is the number of
cycles elapsed since the last reset of the cpu. It is passed as a
parameter to the method as a u64 and must return the earliest time as
a u64 when the access can be done, which can be equal to the passed-in
time.  From there two things can happen: either the running cpu has
enough cycles left to consume to reach that time.  In that case, the
necessary number of cycles is consumed, and the access is done.
Otherwise, when there isn't enough, the remaining cycles are consumed,
the access aborted, scheduling happens, and eventually the access is
redone.  In that case the method is called again with the new current
time, and must return the (probably same) earliest time again.  This
will happen until enough cycles to consume are available to directly
do the access.</p>
<p>This approach allows to for instance handle consecutive DMAs.  A first
DMA grabs the bus for a transfer.  This shows up as the method
answering for the earliest time for access the time of the end of the
dma.  If no timer happens until that time the access will then happen
just after the dma finishes.  But if a timer elapses before that and
as a consequence another dma is queued while the first is running, the
cycle will be aborted for lack of remaining time, and the method will
eventually be called again.  It will then give the time of when the
second dma will finish, and all will be well.</p>
<p>It can also allow to reduce said earlier time when circumstances
require it.  For instance a PIO latch that waits up to 64 cycles that
data arrives can indicate that current time + 64 as a target (which
will trigger a bus error for instance) but if a timer elapses and
fills the latch meanwhile the method will be called again and that
time can just return the current time to let the access pass though.
Beware that if the timer elapsing did not fill the latch then the
method must return the time it returned previously, e.g. the initial
access time + 64, otherwise irrelevant timers happening or simply
scheduling quantum effects will delay the timeout, possibly to
infinity if the quantum is small enough.</p>
<p>Contention handlers on the same address are taken into account in the
<code class="docutils literal notranslate"><span class="pre">before_time</span></code>, <code class="docutils literal notranslate"><span class="pre">before_delay</span></code> then <code class="docutils literal notranslate"><span class="pre">after_delay</span></code> order.
Contention handlers of the same type on the same address at
last-one-wins.  Installing any non-contention handler on a range where
a contention handler was removes it.</p>
</section>
</section>
<section id="address-maps-api">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">4. Address maps API</a><a class="headerlink" href="#address-maps-api" title="Link to this heading">Â¶</a></h2>
<section id="general-api-structure">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">4.1 General API structure</a><a class="headerlink" href="#general-api-structure" title="Link to this heading">Â¶</a></h3>
<p>An address map is a method of a device which fills an <strong>address_map</strong>
structure, usually called <strong>map</strong>, passed by reference.  The method
then can set some global configuration through specific methods and
then provide address range-oriented entries which indicate what should
happen when a specific range is accessed.</p>
<p>The general syntax for entries uses method chaining:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">map</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">).</span><span class="n">handler</span><span class="p">(...).</span><span class="n">handler_qualifier</span><span class="p">(...).</span><span class="n">range_qualifier</span><span class="p">().</span><span class="n">contention</span><span class="p">();</span>
</pre></div>
</div>
<p>The values start and end define the range, the handler() block
determines how the access is handled, the handler_qualifier() block
specifies some aspects of the handler (memory sharing for instance)
and the range_qualifier() block refines the range (mirroring, masking,
lane selection, etc.).  The contention methods handle bus contention
and wait states for cpus supporting them.</p>
<p>The map follows a âlast one winsâ principle, where the handler specified
last is selected when multiple handlers match a given address.</p>
</section>
<section id="global-configurations">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">4.2 Global configurations</a><a class="headerlink" href="#global-configurations" title="Link to this heading">Â¶</a></h3>
<section id="global-masking">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">4.2.1 Global masking</a><a class="headerlink" href="#global-masking" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">map</span><span class="p">.</span><span class="n">global_mask</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
<p>Specifies a mask to be applied to all addresses when accessing the space
that map is installed in.</p>
</section>
<section id="returned-value-on-unmapped-nop-ed-read">
<h4><a class="toc-backref" href="#id20" role="doc-backlink">4.2.2 Returned value on unmapped/nop-ed read</a><a class="headerlink" href="#returned-value-on-unmapped-nop-ed-read" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">map</span><span class="p">.</span><span class="n">unmap_value_low</span><span class="p">();</span>
<span class="n">map</span><span class="p">.</span><span class="n">unmap_value_high</span><span class="p">();</span>
<span class="n">map</span><span class="p">.</span><span class="n">unmap_value</span><span class="p">(</span><span class="n">u8</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>Sets the value to return on reads to an unmapped or nopped-out address.
Low means 0, high ~0.</p>
</section>
</section>
<section id="handler-setting">
<h3><a class="toc-backref" href="#id21" role="doc-backlink">4.3 Handler setting</a><a class="headerlink" href="#handler-setting" title="Link to this heading">Â¶</a></h3>
<section id="method-on-the-current-device">
<h4><a class="toc-backref" href="#id22" role="doc-backlink">4.3.1 Method on the current device</a><a class="headerlink" href="#method-on-the-current-device" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">r</span><span class="p">(</span><span class="n">FUNC</span><span class="p">(</span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">))</span>
<span class="p">(...).</span><span class="n">w</span><span class="p">(</span><span class="n">FUNC</span><span class="p">(</span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">))</span>
<span class="p">(...).</span><span class="n">rw</span><span class="p">(</span><span class="n">FUNC</span><span class="p">(</span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">),</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">))</span>

<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span>
<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span>
<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">)</span>
<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span>
<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span>
<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">()</span>

<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">(</span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>Sets a method of the current device or driver to read, write or both
for the current entry.  The prototype of the method can take multiple
forms making some elements optional.  <code class="docutils literal notranslate"><span class="pre">uNN</span></code> represents <code class="docutils literal notranslate"><span class="pre">u8</span></code>,
<code class="docutils literal notranslate"><span class="pre">u16</span></code>, <code class="docutils literal notranslate"><span class="pre">u32</span></code> or <code class="docutils literal notranslate"><span class="pre">u64</span></code> depending on the data width of the handler.
The handler can be narrower than the bus itself (for instance an 8-bit
device on a 32-bit bus).</p>
<p>The offset passed in is built from the access address.  It starts at
zero at the start of the range, and increments for each <code class="docutils literal notranslate"><span class="pre">uNN</span></code> unit.
An <code class="docutils literal notranslate"><span class="pre">u8</span></code> handler will get an offset in bytes, an <code class="docutils literal notranslate"><span class="pre">u32</span></code> one in double
words.  The <code class="docutils literal notranslate"><span class="pre">mem_mask</span></code> has its bits set where the accessors actually
drive the bit.  Itâs usually built in byte units, but in some cases of
I/O chips ports with per-bit direction registers the resolution can be
at the bit level.</p>
</section>
<section id="method-on-a-different-device">
<h4><a class="toc-backref" href="#id23" role="doc-backlink">4.3.2 Method on a different device</a><a class="headerlink" href="#method-on-a-different-device" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">r</span><span class="p">(</span><span class="n">m_other_device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">other_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">))</span>
<span class="p">(...).</span><span class="n">r</span><span class="p">(</span><span class="s">&quot;other-device-tag&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">other_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">))</span>
<span class="p">(...).</span><span class="n">w</span><span class="p">(</span><span class="n">m_other_device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">other_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">))</span>
<span class="p">(...).</span><span class="n">w</span><span class="p">(</span><span class="s">&quot;other-device-tag&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">other_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">))</span>
<span class="p">(...).</span><span class="n">rw</span><span class="p">(</span><span class="n">m_other_device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">other_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">),</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">other_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">))</span>
<span class="p">(...).</span><span class="n">rw</span><span class="p">(</span><span class="s">&quot;other-device-tag&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">other_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">),</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">other_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">))</span>
</pre></div>
</div>
<p>Sets a method of another device, designated by an object finder
(usually <code class="docutils literal notranslate"><span class="pre">required_device</span></code> or <code class="docutils literal notranslate"><span class="pre">optional_device</span></code>) or its tag, to
read, write or both for the current entry.</p>
</section>
<section id="lambda-function">
<h4><a class="toc-backref" href="#id24" role="doc-backlink">4.3.3 Lambda function</a><a class="headerlink" href="#lambda-function" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">lr</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">}(</span><span class="n">NAME</span><span class="p">([...](</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}))</span>
<span class="p">(...).</span><span class="n">lr</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">}([...](</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="s">&quot;name&quot;</span><span class="p">)</span>
<span class="p">(...).</span><span class="n">lw</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">}(</span><span class="n">NAME</span><span class="p">([...](</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}))</span>
<span class="p">(...).</span><span class="n">lw</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">}([...](</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="s">&quot;name&quot;</span><span class="p">)</span>
<span class="p">(...).</span><span class="n">lrw</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">}(</span><span class="n">NAME</span><span class="p">(</span><span class="n">read</span><span class="p">),</span><span class="w"> </span><span class="n">NAME</span><span class="p">(</span><span class="n">write</span><span class="p">))</span>
<span class="p">(...).</span><span class="n">lrw</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">}(</span><span class="n">read</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name_r&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">write</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;name_w&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Sets a lambda called on read, write or both.  The lambda prototype can
be any of the six available for methods.  One can either use <code class="docutils literal notranslate"><span class="pre">NAME()</span></code>
over the whole lambda, or provide a name after the lambda definition.
The number is the data width of the access, e.g. the NN.</p>
</section>
<section id="direct-memory-access">
<h4><a class="toc-backref" href="#id25" role="doc-backlink">4.3.4 Direct memory access</a><a class="headerlink" href="#direct-memory-access" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">rom</span><span class="p">()</span>
<span class="p">(...).</span><span class="n">writeonly</span><span class="p">()</span>
<span class="p">(...).</span><span class="n">ram</span><span class="p">()</span>
</pre></div>
</div>
<p>Selects the range to access a memory zone as read-only, write-only or
read/write respectively.  Specific handler qualifiers specify the
location of this memory zone.  There are two cases when no qualifier is
acceptable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ram()</span></code> gives an anonymous RAM zone not accessible outside of the
address space.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rom()</span></code> when the memory map is used in an <code class="docutils literal notranslate"><span class="pre">AS_PROGRAM</span></code>
space of a (CPU) device which names is also the name of a region.
Then the memory zone points to that region at the offset
corresponding to the start of the zone.</p></li>
</ul>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">rom</span><span class="p">().</span><span class="n">region</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">region</span></code> qualifier causes a read-only zone point to the contents
of a given region at a given offset.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">rom</span><span class="p">().</span><span class="n">share</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
<span class="p">(...).</span><span class="n">writeonly</span><span class="p">.</span><span class="n">share</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
<span class="p">(...).</span><span class="n">ram</span><span class="p">().</span><span class="n">share</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">share</span></code> qualifier causes the zone point to a shared memory region
identified by its name.  If the share is present in multiple spaces, the
size, bus width, and, if the bus is more than byte-wide, the Endianness
must match.</p>
</section>
<section id="bank-access">
<h4><a class="toc-backref" href="#id26" role="doc-backlink">4.3.5 Bank access</a><a class="headerlink" href="#bank-access" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">bankr</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
<span class="p">(...).</span><span class="n">bankw</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
<span class="p">(...).</span><span class="n">bankrw</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Sets the range to point at the contents of a memory bank in read, write
or read/write mode.</p>
</section>
<section id="port-access">
<h4><a class="toc-backref" href="#id27" role="doc-backlink">4.3.6 Port access</a><a class="headerlink" href="#port-access" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">portr</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
<span class="p">(...).</span><span class="n">portw</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
<span class="p">(...).</span><span class="n">portrw</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Sets the range to point at an I/O port.</p>
</section>
<section id="dropped-access">
<h4><a class="toc-backref" href="#id28" role="doc-backlink">4.3.7 Dropped access</a><a class="headerlink" href="#dropped-access" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">nopr</span><span class="p">()</span>
<span class="p">(...).</span><span class="n">nopw</span><span class="p">()</span>
<span class="p">(...).</span><span class="n">noprw</span><span class="p">()</span>
</pre></div>
</div>
<p>Sets the range to drop the access without logging.  When reading, the
unmap value is returned.</p>
</section>
<section id="unmapped-access">
<h4><a class="toc-backref" href="#id29" role="doc-backlink">4.3.8 Unmapped access</a><a class="headerlink" href="#unmapped-access" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">unmapr</span><span class="p">()</span>
<span class="p">(...).</span><span class="n">unmapw</span><span class="p">()</span>
<span class="p">(...).</span><span class="n">unmaprw</span><span class="p">()</span>
</pre></div>
</div>
<p>Sets the range to drop the access with logging.  When reading, the
unmap value is returned.</p>
</section>
<section id="subdevice-mapping">
<h4><a class="toc-backref" href="#id30" role="doc-backlink">4.3.9 Subdevice mapping</a><a class="headerlink" href="#subdevice-mapping" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">m</span><span class="p">(</span><span class="n">m_other_device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">other_device</span><span class="o">::</span><span class="n">map_method</span><span class="p">))</span>
<span class="p">(...).</span><span class="n">m</span><span class="p">(</span><span class="s">&quot;other-device-tag&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">other_device</span><span class="o">::</span><span class="n">map_method</span><span class="p">))</span>
</pre></div>
</div>
<p>Includes a device-defined submap.  The start of the range indicates
where the address zero of the submap ends up, and the end of the range
clips the submap if needed.  Note that range qualifiers (defined
later) apply.</p>
<p>Currently, only handlers are allowed in submaps and not memory zones
or banks.</p>
</section>
</section>
<section id="range-qualifiers">
<h3><a class="toc-backref" href="#id31" role="doc-backlink">4.4 Range qualifiers</a><a class="headerlink" href="#range-qualifiers" title="Link to this heading">Â¶</a></h3>
<section id="mirroring">
<h4><a class="toc-backref" href="#id32" role="doc-backlink">4.4.1 Mirroring</a><a class="headerlink" href="#mirroring" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">mirror</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p>Duplicate the range on the addresses reachable by setting any of the 1
bits present in mask.  For instance, a range 0-0x1f with mirror 0x300
will be present on 0-0x1f, 0x100-0x11f, 0x200-0x21f and 0x300-0x31f.
The addresses passed in to the handler stay in the 0-0x1f range, the
mirror bits are not seen by the handler.</p>
</section>
<section id="masking">
<h4><a class="toc-backref" href="#id33" role="doc-backlink">4.4.2 Masking</a><a class="headerlink" href="#masking" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p>Only valid with handlers, the address will be masked with the mask
before being passed to the handler.</p>
</section>
<section id="selection">
<h4><a class="toc-backref" href="#id34" role="doc-backlink">4.4.3 Selection</a><a class="headerlink" href="#selection" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">select</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p>Only valid with handlers, the range will be mirrored as with mirror,
but the mirror address bits are preserved in the offset passed to the
handler when it is called.  This is useful for devices like sound
chips where the low bits of the address select a function and the high
bits a voice number.</p>
</section>
<section id="sub-unit-selection">
<h4><a class="toc-backref" href="#id35" role="doc-backlink">4.4.4 Sub-unit selection</a><a class="headerlink" href="#sub-unit-selection" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">umask16</span><span class="p">(</span><span class="mi">16</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span>
<span class="p">(...).</span><span class="n">umask32</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span>
<span class="p">(...).</span><span class="n">umask64</span><span class="p">(</span><span class="mi">64</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p>Only valid with handlers and submaps, selects which data lines of the
bus are actually connected to the handler or the device.  The mask value
should be a multiple of a byte, e.g. the mask is a series of 00 and ff.
The offset will be adjusted accordingly, so that a difference of 1 means
the next handled unit in the access.</p>
<p>If the mask is narrower than the bus width, the mask is replicated in
the upper lines.</p>
</section>
<section id="chip-select-handling-on-sub-unit">
<h4><a class="toc-backref" href="#id36" role="doc-backlink">4.4.5 Chip select handling on sub-unit</a><a class="headerlink" href="#chip-select-handling-on-sub-unit" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">cselect</span><span class="p">(</span><span class="mi">16</span><span class="o">/</span><span class="mi">32</span><span class="o">/</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>When a device is connected to part of the bus, like a byte on a
16-bits bus, the target handler is only activated when that part is
actually accessed.  In some cases, very often byte access on a 68000
16-bits bus, the actual hardware only checks the word address and not
if the correct byte is accessed.  <code class="docutils literal notranslate"><span class="pre">cswidth</span></code> tells the memory system to
trigger the handler if a wider part of the bus is accessed.  The
parameter is that trigger width (would be 16 in the 68000 case).</p>
</section>
<section id="user-flags">
<h4><a class="toc-backref" href="#id37" role="doc-backlink">4.4.6 User flags</a><a class="headerlink" href="#user-flags" title="Link to this heading">Â¶</a></h4>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">flags</span><span class="p">(</span><span class="mi">16</span><span class="o">-</span><span class="n">bits</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span>
</pre></div>
</div>
<p>This parameter allows to set user-defined flags on the handler which
can then be retrieved by an accessing device to change their
behaviour.  An example of use the i960 which marks burstable zones
that way (they have a specific hardware-level support).</p>
</section>
</section>
<section id="contention">
<h3><a class="toc-backref" href="#id38" role="doc-backlink">4.5 Contention</a><a class="headerlink" href="#contention" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="p">(...).</span><span class="n">before_time</span><span class="p">(</span><span class="n">method</span><span class="p">).(...)</span>
<span class="p">(...).</span><span class="n">before_delay</span><span class="p">(</span><span class="n">method</span><span class="p">).(...)</span>
<span class="p">(...).</span><span class="n">after_delay</span><span class="p">(</span><span class="n">method</span><span class="p">).(...)</span>
</pre></div>
</div>
<p>These three methods allow to add the contention methods to a handler.
See section <a class="reference internal" href="#id1">3.5</a>.  Multiple methods can be handler to one handler.</p>
</section>
<section id="view-setup">
<h3><a class="toc-backref" href="#id39" role="doc-backlink">4.6 View setup</a><a class="headerlink" href="#view-setup" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">map</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">).</span><span class="n">view</span><span class="p">(</span><span class="n">m_view</span><span class="p">);</span>
<span class="n">m_view</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">start1</span><span class="p">,</span><span class="w"> </span><span class="n">end1</span><span class="p">).[...];</span>
</pre></div>
</div>
<p>A view is setup in a address map with the view method.  The only
qualifier accepted is mirror.  The âdisabledâ version of the view will
include what was in the range prior to the view setup.</p>
<p>The different variants are setup by indexing the view with the variant
number and setting up an entry in the usual way.  The entries within a
variant must of course stay within the range.  There are no other
additional constraints.  The contents of a variant, by default, are
what was there before, i.e. the contents of the disabled view, and
setting it up allows part or all of it to be overridden.</p>
<p>Variants can only be setup once the view itself has been setup with
the <code class="docutils literal notranslate"><span class="pre">view</span></code> method.</p>
<p>A view can only be put in one address map and in only one position.
If multiple views have identical or similar contents, remember that
setting up a map is nothing more than a method call, and creating a
second method to setup a view is perfectly reasonable.  A view is of
type <code class="docutils literal notranslate"><span class="pre">memory_view</span></code> and an indexed entry (e.g. a variant to setup) is
of type <code class="docutils literal notranslate"><span class="pre">memory_view::memory_view_entryÂ &amp;</span></code>.</p>
<p>A view can be installed in another view, but donât forget that a view
can be installed only once.  A view can also be part of âwhat was there
beforeâ.</p>
</section>
</section>
<section id="address-space-dynamic-mapping-api">
<h2><a class="toc-backref" href="#id40" role="doc-backlink">5. Address space dynamic mapping API</a><a class="headerlink" href="#address-space-dynamic-mapping-api" title="Link to this heading">Â¶</a></h2>
<section id="id2">
<h3><a class="toc-backref" href="#id41" role="doc-backlink">5.1 General API structure</a><a class="headerlink" href="#id2" title="Link to this heading">Â¶</a></h3>
<p>A series of methods allow the bus decoding of an address space to be
changed on-the-fly.  Theyâre powerful but have some issues:</p>
<ul class="simple">
<li><p>changing the mappings repeatedly can be slow</p></li>
<li><p>the address space state is not saved in the saved states, so it has to
be rebuilt after state load</p></li>
<li><p>they can be hidden anywhere rather than be grouped in an address map,
which can be less readable</p></li>
</ul>
<p>The methods, rather than decomposing the information in handler, handler
qualifier and range qualifier, put them all together as method
parameters.  To make things a little more readable, lots of them are
optional.</p>
</section>
<section id="handler-mapping">
<h3><a class="toc-backref" href="#id42" role="doc-backlink">5.2 Handler mapping</a><a class="headerlink" href="#handler-mapping" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span>
<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method_m</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span>
<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method_mo</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">)</span>
<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method_s</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span>
<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method_sm</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">)</span>
<span class="n">uNN</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">read_method_smo</span><span class="p">()</span>

<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method_m</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method_mo</span><span class="p">(</span><span class="n">address_space</span><span class="w"> </span><span class="o">&amp;</span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method_s</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method_sm</span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="kt">void</span><span class="w"> </span><span class="n">my_device</span><span class="o">::</span><span class="n">write_method_smo</span><span class="p">(</span><span class="n">uNN</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>

<span class="n">readNN_delegate</span><span class="w">   </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">read_method</span><span class="p">))</span>
<span class="n">readNNm_delegate</span><span class="w">  </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">read_method_m</span><span class="p">))</span>
<span class="n">readNNmo_delegate</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">read_method_mo</span><span class="p">))</span>
<span class="n">readNNs_delegate</span><span class="w">  </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">read_method_s</span><span class="p">))</span>
<span class="n">readNNsm_delegate</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">read_method_sm</span><span class="p">))</span>
<span class="n">readNNsmo_delegate</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">read_method_smo</span><span class="p">))</span>

<span class="n">writeNN_delegate</span><span class="w">   </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">write_method</span><span class="p">))</span>
<span class="n">writeNNm_delegate</span><span class="w">  </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">write_method_m</span><span class="p">))</span>
<span class="n">writeNNmo_delegate</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">write_method_mo</span><span class="p">))</span>
<span class="n">writeNNs_delegate</span><span class="w">  </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">write_method_s</span><span class="p">))</span>
<span class="n">writeNNsm_delegate</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">write_method_sm</span><span class="p">))</span>
<span class="n">writeNNsmo_delegate</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">FUNC</span><span class="p">(</span><span class="n">write_method_smo</span><span class="p">))</span>
</pre></div>
</div>
<p>To be added to a map, a method call and the device it is called onto
have to be wrapped in the appropriate delegate type.  There are twelve
types, for read and for write and for all six possible prototypes.
Note that as all delegates, they can also wrap lambdas.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">space</span><span class="p">.</span><span class="n">install_read_handler</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">read_delegate</span><span class="p">,</span><span class="w"> </span><span class="n">unitmask</span><span class="p">,</span><span class="w"> </span><span class="n">cswidth</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_read_handler</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmask</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">addrselect</span><span class="p">,</span><span class="w"> </span><span class="n">read_delegate</span><span class="p">,</span><span class="w"> </span><span class="n">unitmask</span><span class="p">,</span><span class="w"> </span><span class="n">cswidth</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_handler</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">write_delegate</span><span class="p">,</span><span class="w"> </span><span class="n">unitmask</span><span class="p">,</span><span class="w"> </span><span class="n">cswidth</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_handler</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmask</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">addrselect</span><span class="p">,</span><span class="w"> </span><span class="n">write_delegate</span><span class="p">,</span><span class="w"> </span><span class="n">unitmask</span><span class="p">,</span><span class="w"> </span><span class="n">cswidth</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_handler</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">read_delegate</span><span class="p">,</span><span class="w"> </span><span class="n">write_delegate</span><span class="p">,</span><span class="w"> </span><span class="n">unitmask</span><span class="p">,</span><span class="w"> </span><span class="n">cswidth</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_handler</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmask</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">addrselect</span><span class="p">,</span><span class="w"> </span><span class="n">read_delegate</span><span class="p">,</span><span class="w"> </span><span class="n">write_delegate</span><span class="p">,</span><span class="w"> </span><span class="n">unitmask</span><span class="p">,</span><span class="w"> </span><span class="n">cswidth</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>These six methods allow to install delegate-wrapped handlers in a live
address space. Either plain or with mask, mirror and select.  In the
read/write case both delegates must be of the same flavor (<code class="docutils literal notranslate"><span class="pre">smo</span></code>
stuff) to avoid a combinatorial explosion of method types.  The
<code class="docutils literal notranslate"><span class="pre">unitmask</span></code>, <code class="docutils literal notranslate"><span class="pre">cswidth</span></code> and <code class="docutils literal notranslate"><span class="pre">flags</span></code> arguments are optional.</p>
</section>
<section id="direct-memory-range-mapping">
<h3><a class="toc-backref" href="#id43" role="doc-backlink">5.3 Direct memory range mapping</a><a class="headerlink" href="#direct-memory-range-mapping" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">space</span><span class="p">.</span><span class="n">install_rom</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_rom</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_rom</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_writeonly</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_writeonly</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_writeonly</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_ram</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_ram</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_ram</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pointer</span><span class="p">)</span>
</pre></div>
</div>
<p>Installs a memory block in an address space, with or without mirror
and flags.  <code class="docutils literal notranslate"><span class="pre">_rom</span></code> is read-only, <code class="docutils literal notranslate"><span class="pre">_ram</span></code> is read/write,
<code class="docutils literal notranslate"><span class="pre">_writeonly</span></code> is write-only.  The pointer must be non-null, this
method will not allocate the memory.</p>
</section>
<section id="bank-mapping">
<h3><a class="toc-backref" href="#id44" role="doc-backlink">5.4 Bank mapping</a><a class="headerlink" href="#bank-mapping" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">space</span><span class="p">.</span><span class="n">install_read_bank</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bank</span><span class="w"> </span><span class="o">*</span><span class="n">bank</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_read_bank</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bank</span><span class="w"> </span><span class="o">*</span><span class="n">bank</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_read_bank</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bank</span><span class="w"> </span><span class="o">*</span><span class="n">bank</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_bank</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bank</span><span class="w"> </span><span class="o">*</span><span class="n">bank</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_bank</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bank</span><span class="w"> </span><span class="o">*</span><span class="n">bank</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_bank</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bank</span><span class="w"> </span><span class="o">*</span><span class="n">bank</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_bank</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bank</span><span class="w"> </span><span class="o">*</span><span class="n">bank</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_bank</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bank</span><span class="w"> </span><span class="o">*</span><span class="n">bank</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_bank</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bank</span><span class="w"> </span><span class="o">*</span><span class="n">bank</span><span class="p">)</span>
</pre></div>
</div>
<p>Install an existing memory bank for reading, writing or both in an
address space.</p>
</section>
<section id="port-mapping">
<h3><a class="toc-backref" href="#id45" role="doc-backlink">5.5 Port mapping</a><a class="headerlink" href="#port-mapping" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">space</span><span class="p">.</span><span class="n">install_read_port</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">rtag</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_read_port</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">rtag</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_read_port</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">rtag</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_port</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">wtag</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_port</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">wtag</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_port</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">wtag</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_port</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">rtag</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">wtag</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_port</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">rtag</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">wtag</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_port</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">rtag</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">wtag</span><span class="p">)</span>
</pre></div>
</div>
<p>Install ports by name for reading, writing or both.</p>
</section>
<section id="dropped-accesses">
<h3><a class="toc-backref" href="#id46" role="doc-backlink">5.6 Dropped accesses</a><a class="headerlink" href="#dropped-accesses" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">space</span><span class="p">.</span><span class="n">nop_read</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">nop_write</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">nop_readwrite</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>Drops the accesses for a given range with an optional mirror and flags;</p>
</section>
<section id="unmapped-accesses">
<h3><a class="toc-backref" href="#id47" role="doc-backlink">5.7 Unmapped accesses</a><a class="headerlink" href="#unmapped-accesses" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">space</span><span class="p">.</span><span class="n">unmap_read</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">unmap_write</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">unmap_readwrite</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>Unmaps the accesses (e.g. logs the access as unmapped) for a given range
with an optional mirror and flags.</p>
</section>
<section id="device-map-installation">
<h3><a class="toc-backref" href="#id48" role="doc-backlink">5.8 Device map installation</a><a class="headerlink" href="#device-map-installation" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">space</span><span class="p">.</span><span class="n">install_device</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">unitmask</span><span class="p">,</span><span class="w"> </span><span class="n">cswidth</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
</pre></div>
</div>
<p>Install a device address with an address map in a space.  The
<code class="docutils literal notranslate"><span class="pre">unitmask</span></code>, <code class="docutils literal notranslate"><span class="pre">cswidth</span></code> and <code class="docutils literal notranslate"><span class="pre">flags</span></code> arguments are optional.</p>
</section>
<section id="id3">
<h3><a class="toc-backref" href="#id49" role="doc-backlink">5.9 Contention</a><a class="headerlink" href="#id3" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">ws_time_delegate</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">device_delegate</span><span class="o">&lt;</span><span class="n">u64</span><span class="w"> </span><span class="p">(</span><span class="n">offs_t</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">ws_delay_delegate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device_delegate</span><span class="o">&lt;</span><span class="n">u32</span><span class="w"> </span><span class="p">(</span><span class="n">offs_t</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">space</span><span class="p">.</span><span class="n">install_read_before_time</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">ws_time_delegate</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_before_time</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">ws_time_delegate</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_before_time</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">ws_time_delegate</span><span class="p">)</span>

<span class="n">space</span><span class="p">.</span><span class="n">install_read_before_delay</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">ws_delay_delegate</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_before_delay</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">ws_delay_delegate</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_before_delay</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">ws_delay_delegate</span><span class="p">)</span>

<span class="n">space</span><span class="p">.</span><span class="n">install_read_after_delay</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">ws_delay_delegate</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_write_after_delay</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">ws_delay_delegate</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_after_delay</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">ws_delay_delegate</span><span class="p">)</span>
</pre></div>
</div>
<p>Install a contention handler in the decode path.  The addrmirror
parameter is optional.</p>
</section>
<section id="view-installation">
<h3><a class="toc-backref" href="#id50" role="doc-backlink">5.10 View installation</a><a class="headerlink" href="#view-installation" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">space</span><span class="p">.</span><span class="n">install_view</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">view</span><span class="p">)</span>
<span class="n">space</span><span class="p">.</span><span class="n">install_view</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">addrmirror</span><span class="p">,</span><span class="w"> </span><span class="n">view</span><span class="p">)</span>

<span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">install</span><span class="p">...</span>
</pre></div>
</div>
<p>Installs a view in a space.  This can be only done once and in only
one space, and the view must not have been setup through the address
map API before.  Once the view is installed, variants can be selected
by indexing to call a dynamic mapping method on it.</p>
<p>A view can be installed into a variant of another view without issues,
with only the usual constraint of single installation.</p>
</section>
<section id="taps">
<h3><a class="toc-backref" href="#id51" role="doc-backlink">5.11 Taps</a><a class="headerlink" href="#taps" title="Link to this heading">Â¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">tap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="n">offs_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">uNN</span><span class="w"> </span><span class="n">mem_mask</span><span class="p">)</span>

<span class="n">memory_passthrough_handler</span><span class="w"> </span><span class="n">mph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">space</span><span class="p">.</span><span class="n">install_read_tap</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">read_tap</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mph</span><span class="p">);</span>
<span class="n">memory_passthrough_handler</span><span class="w"> </span><span class="n">mph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">space</span><span class="p">.</span><span class="n">install_write_tap</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">write_tap</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mph</span><span class="p">);</span>
<span class="n">memory_passthrough_handler</span><span class="w"> </span><span class="n">mph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">space</span><span class="p">.</span><span class="n">install_readwrite_tap</span><span class="p">(</span><span class="n">addrstart</span><span class="p">,</span><span class="w"> </span><span class="n">addrend</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">read_tap</span><span class="p">,</span><span class="w"> </span><span class="n">write_tap</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mph</span><span class="p">);</span>

<span class="n">mph</span><span class="p">.</span><span class="n">remove</span><span class="p">();</span>
</pre></div>
</div>
<p>A tap is a method that is be called when a specific range of addresses
is accessed without overriding the actual access.  Taps can change the
data passed around.  A write tap happens before the access, and can
change the value to be written.  A read tap happens after the access,
and can change the value returned.</p>
<p>Taps must be of the same width and alignement than the bus.  Multiple
taps can act over the same addresses.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">memory_passthrough_handler</span></code> object collates a number of taps
and allow to remove them all in one call.  The <code class="docutils literal notranslate"><span class="pre">mph</span></code> parameter is
optional and a new one will be created if absent.</p>
<p>Taps are lost when a new handler is installed at the same addresses
(under the usual principle of last one wins).  If they need to be
preserved, one should install a change notifier on the address space,
and remove + reinstall the taps when notified.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="device_sound_interface.html" class="btn btn-neutral float-left" title="The device_sound_interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="cpu_device.html" class="btn btn-neutral float-right" title="CPU devices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1997-2025, MAMEdev and contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>