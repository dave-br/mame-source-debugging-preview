<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Input System &mdash; MAME Documentation 0.279 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/documentation_options.js?v=1a7c6e39"></script>
        <script src="../_static/doctools.js?v=9bcbadda"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The device_memory_interface" href="device_memory_interface.html" />
    <link rel="prev" title="Object Finders" href="object_finders.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MAME Documentation
          </a>
              <div class="version">
                0.279
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../whatis.html">What is MAME</a></li>
<li class="toctree-l1"><a class="reference internal" href="../healthwarning.html">Health Warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../initialsetup/index.html">Getting MAME prepared</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usingmame/index.html">Basic MAME Usage and Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../commandline/index.html">MAME Command-line Usage and OS-Specific Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plugins/index.html">Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/index.html">Advanced configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../debugger/index.html">MAME Debugger</a></li>
<li class="toctree-l1"><a class="reference internal" href="../luascript/index.html">Lua Scripting Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">MAME External Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributing to MAME</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Technical Specifications</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="naming.html">MAME Naming Conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="layout_files.html">MAME Layout Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="layout_script.html">MAME Layout Scripting</a></li>
<li class="toctree-l2"><a class="reference internal" href="object_finders.html">Object Finders</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Input System</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_memory_interface.html">The device_memory_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_rom_interface.html">The device_rom_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_disasm_interface.html">The device_disasm_interface and the disassemblers</a></li>
<li class="toctree-l2"><a class="reference internal" href="device_sound_interface.html">The device_sound_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="memory.html">Emulated system memory and address spaces management</a></li>
<li class="toctree-l2"><a class="reference internal" href="cpu_device.html">CPU devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="floppy.html">The new floppy subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="nscsi.html">The new SCSI subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="m6502.html">The new 6502 family implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="uml_instructions.html">UML Instruction Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="poly_manager.html">Software 3D Rendering in MAME</a></li>
<li class="toctree-l2"><a class="reference internal" href="audio_effects.html">Audio effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="osd_audio.html">OSD audio support</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../security.html">MAME and security concerns</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">The MAME License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MAME Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Technical Specifications</a></li>
      <li class="breadcrumb-item active">Input System</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="input-system">
<span id="inputsystem"></span><h1>Input System<a class="headerlink" href="#input-system" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#components" id="id2">Components</a></p>
<ul>
<li><p><a class="reference internal" href="#input-device" id="id3">Input device</a></p></li>
<li><p><a class="reference internal" href="#input-device-item" id="id4">Input device item</a></p></li>
<li><p><a class="reference internal" href="#i-o-port-field" id="id5">I/O port field</a></p></li>
<li><p><a class="reference internal" href="#input-manager" id="id6">Input manager</a></p></li>
<li><p><a class="reference internal" href="#i-o-port-manager" id="id7">I/O port manager</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#structures-and-data-types" id="id8">Structures and data types</a></p>
<ul>
<li><p><a class="reference internal" href="#input-code" id="id9">Input code</a></p></li>
<li><p><a class="reference internal" href="#input-sequence" id="id10">Input sequence</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#input-provider-modules" id="id11">Input provider modules</a></p></li>
<li><p><a class="reference internal" href="#player-positions" id="id12">Player positions</a></p></li>
<li><p><a class="reference internal" href="#updating-i-o-port-fields" id="id13">Updating I/O port fields</a></p>
<ul>
<li><p><a class="reference internal" href="#updating-digital-fields" id="id14">Updating digital fields</a></p></li>
<li><p><a class="reference internal" href="#updating-absolute-analog-fields" id="id15">Updating absolute analog fields</a></p></li>
<li><p><a class="reference internal" href="#updating-relative-analog-fields" id="id16">Updating relative analog fields</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="introduction">
<span id="inputsystem-intro"></span><h2><a class="toc-backref" href="#id1" role="doc-backlink">Introduction</a><a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>The variety of systems MAME emulates, as well as the variation in host
systems and peripherals, necessitates a flexible, configurable input
system.</p>
<p>Note that the input system is concerned with low-level user input.
High-level user interaction, involving things like text input and
pointing devices, is handled separately.</p>
</section>
<section id="components">
<span id="inputsystem-components"></span><h2><a class="toc-backref" href="#id2" role="doc-backlink">Components</a><a class="headerlink" href="#components" title="Link to this heading">¶</a></h2>
<p>From the emulated system’s point of view, the input system has the
following conceptual components.</p>
<section id="input-device">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">Input device</a><a class="headerlink" href="#input-device" title="Link to this heading">¶</a></h3>
<p>Input devices supply input values.  An input device typically
corresponds to a physical device in the host system, for example a
keyboard, mouse or game controller.  However, there isn’t always a
one-to-one correspondence between input devices and physical devices.
For example the SDL keyboard provider module aggregates all keyboards
into a single input device, and the Win32 lightgun provider module can
present two input devices using input from a single mouse.</p>
<p>Input devices are identified by their device class (keyboard, mouse,
joystick or lightgun) and device number within the class.  Input
provider modules can also supply an implementation-dependent identifier
to allow the user to configure stable device numbering.</p>
<p>Note that input devices are unrelated to emulated devices (<code class="docutils literal notranslate"><span class="pre">device_t</span></code>
implementations) despite the similar name.</p>
</section>
<section id="input-device-item">
<h3><a class="toc-backref" href="#id4" role="doc-backlink">Input device item</a><a class="headerlink" href="#input-device-item" title="Link to this heading">¶</a></h3>
<p>Also known as a <strong>control</strong>, and input device item corresponds to a
input source that produces a single value.  This usually corresponds to
a physical control or sensor, for example a joystick axis, a button or
an accelerometer.</p>
<p>MAME supports three kinds of controls: <strong>switches</strong>, <strong>absolute axes</strong>
and <strong>relative axes</strong>:</p>
<ul class="simple">
<li><p>Switches produce the value 0 when inactive (released or off) or 1 when
active (pressed or on).</p></li>
<li><p>Absolute axes produce a value normalised to the range -65,536 to
65,536 with zero corresponding to the neutral position.</p></li>
<li><p>Relative axes produce a value corresponding to the movement since the
previous input update.  Mouse-like devices scale values to
approximately 512 per nominal 100 DPI pixel.</p></li>
</ul>
<p>Negative axis values should correspond to directions up, to the left,
away from the player, or anti-clockwise.  For single-ended axes (e.g.
pedals or displacement-sensitive triggers and buttons), only zero and
the negative portion of the range should be used.</p>
<p>Switches are used to represent controls that naturally have two distinct
states, like buttons and toggle switches.</p>
<p>Absolute axes are used to represent controls with a definite range
and/or neutral position.  Examples include steering wheels with limit
stops, joystick axes, and displacement-sensitive triggers.</p>
<p>Relative axes are used to represent controls with an effectively
infinite range.  Examples include mouse/trackball axes, incremental
encoder dials, and gyroscopes.</p>
<p>Accelerometers and force sensing joystick axes should be represented as
absolute axes, even though the range is theoretically open-ended.  In
practice, there is a limit to the range the transducers can report,
which is usually substantially larger than needed for normal operation.</p>
<p>Input device items are identified by their associated device’s class and
device number along with an <strong>input item ID</strong>.  MAME supplies item IDs
for common types of controls.  Additional controls or controls that do
not correspond to a common type are dynamically assigned item IDs.  MAME
supports hundreds to items per input device.</p>
</section>
<section id="i-o-port-field">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">I/O port field</a><a class="headerlink" href="#i-o-port-field" title="Link to this heading">¶</a></h3>
<p>An I/O port field represents an input source in an emulated device or
system.  Most types of I/O port fields can be assigned one or more
combinations of controls, allowing the user to control the input to
the emulated system.</p>
<p>Similarly to input device items, there are multiple types of I/O port
fields:</p>
<ul class="simple">
<li><p><strong>Digital fields</strong> function as switches that produce one of two
distinct values.  They are used for keyboard keys, eight-way joystick
direction switches, toggle switches, photointerruptors and other
emulated inputs that function as two-position switches.</p></li>
<li><p><strong>Absolute analog fields</strong> have a range with defined minimum, maximum
and neutral positions.  They are used for analog joystick axes,
displacement-sensitive pedals, paddle knobs, and other emulated inputs
with a defined range.</p></li>
<li><p><strong>Relative analog fields</strong> have a range with defined minimum, maximum
and starting positions.  On each update, the value accumulates and
wraps when it passes either end of the range.  Functionally, this is
like the output of an up/down counter connected to an incremental
encoder.  They are used for mouse/trackball axes, steering wheels
without limit stops, and other emulated inputs that have no range
limits.</p></li>
<li><p>DIP switch, configuration and adjuster fields allow the user to set
the value through MAME’s user interface.</p></li>
<li><p>Additional special field types are used to produce fixed or
programmatically generated values.</p></li>
</ul>
<p>A digital field appears to the user as a single assignable input, which
accepts switch values.</p>
<p>An analog field appears to the user as three assignable inputs: an
<strong>axis input</strong>, which accepts axis values; and an <strong>increment input</strong>
and a <strong>decrement input</strong> which accept switch values.</p>
</section>
<section id="input-manager">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Input manager</a><a class="headerlink" href="#input-manager" title="Link to this heading">¶</a></h3>
<p>The input manager has several responsibilities:</p>
<ul class="simple">
<li><p>Tracking the available input devices in the system.</p></li>
<li><p>Reading input values.</p></li>
<li><p>Converting between internal identifier values, configuration token
strings and display strings.</p></li>
</ul>
<p>In practice, emulated devices and systems rarely interact with the input
manager directly.  The most common reason to access the input manager is
implementing special debug controls, which should be disabled in release
builds.  Plugins that respond to input need to call the input manager to
read inputs.</p>
</section>
<section id="i-o-port-manager">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">I/O port manager</a><a class="headerlink" href="#i-o-port-manager" title="Link to this heading">¶</a></h3>
<p>The I/O port manager’s primary responsibilities include:</p>
<ul class="simple">
<li><p>Managing assignments of controls to I/O port fields and user interface
actions.</p></li>
<li><p>Reading input values via the input manager and updating I/O port field
values.</p></li>
</ul>
<p>Like the input manager, the I/O port manager is largely transparent to
emulated devices and systems.  You just need to set up your I/O ports
and fields, and the I/O port manager handles the rest.</p>
</section>
</section>
<section id="structures-and-data-types">
<span id="inputsystem-structures"></span><h2><a class="toc-backref" href="#id8" role="doc-backlink">Structures and data types</a><a class="headerlink" href="#structures-and-data-types" title="Link to this heading">¶</a></h2>
<p>The following data types are used for dealing with input.</p>
<section id="input-code">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Input code</a><a class="headerlink" href="#input-code" title="Link to this heading">¶</a></h3>
<p>An input code specifies an input device item and how it should be
interpreted.  It is a tuple consisting of the following values: <strong>device
class</strong>, <strong>device number</strong>, <strong>item class</strong>, <strong>item modifier</strong> and <strong>item
ID</strong>:</p>
<ul class="simple">
<li><p>The device class, device number and item ID together identify the
input device item to read.</p></li>
<li><p>The item class specifies the type of output value desired: switch,
absolute axis or relative axis.  Axis values can be converted to
switch values by specifying an appropriate modifier.</p></li>
<li><p>The modifier specifies how a value should be interpreted.  Valid
options depend on the type of input device item and the specified
item class.</p></li>
</ul>
<p>If the specified input item is a switch, it can only be read using the
switch class, and no modifiers are supported.  Attempting to read a
switch as an absolute or relative axis always returns zero.</p>
<p>If the specified input item is an absolute axis, it can be read as an
absolute axis or as a switch:</p>
<ul class="simple">
<li><p>Reading an absolute axis item as an absolute axis returns the current
state of the control, potentially transformed if a modifier is
specified.  Supported modifiers are <strong>reverse</strong> to reverse the range
of the control, <strong>positive</strong> to map the positive range of the control
onto the output (zero corresponding to -65,536 and 65,536
corresponding to 65,536), and <strong>negative</strong> to map the negative range
of the control onto the output (zero corresponding to -65,536 and
-65,536 corresponding to 65,536).</p></li>
<li><p>Reading an absolute axis item as a switch returns zero or 1 depending
on whether the control is past a threshold in the direction specified
by the modifier.  Use the <strong>negative</strong> modifier to return 1 when the
control is beyond the threshold in the negative direction (up or
left), or the <strong>positive</strong> modifier to return 1 when the control is
beyond the threshold in the positive direction (down or right).  There
are two special pairs of modifiers, <strong>left</strong>/<strong>right</strong> and
<strong>up</strong>/<strong>down</strong> that are only applicable to the primary X/Y axes of
joystick devices.  The user can specify a <em>joystick map</em> to control
how these modifiers interpret joystick movement.</p></li>
<li><p>Attempting to read an absolute axis item as a relative axis always
returns zero.</p></li>
</ul>
<p>If the specified input item is a relative axis, it can be read as a
relative axis or as a switch:</p>
<ul class="simple">
<li><p>Reading a relative axis item as a relative axis returns the change in
value since the last input update.  The only supported modifier is
<strong>reverse</strong>, which negates the value, reversing the direction.</p></li>
<li><p>Reading a relative axis as a switch returns 1 if the control moved in
the direction specified by the modifier since the last input update.
Use the <strong>negative</strong>/<strong>left</strong>/<strong>up</strong> modifiers to return 1 when the
control has been moved in the negative direction (up or left), or the
<strong>positive</strong>/<strong>right</strong>/<strong>down</strong> modifiers to return 1 when the control
has moved in the positive direction (down or right).</p></li>
<li><p>Attempting to read a relative axis item as an absolute axis always
returns zero.</p></li>
</ul>
<p>There are also special input codes used for specifying how multiple
controls are to be combined in an input sequence.</p>
<p>The most common place you’ll encounter input codes in device and system
driver code is when specifying initial assignments for I/O port fields
that don’t have default assignments supplied by the core.  The
<code class="docutils literal notranslate"><span class="pre">PORT_CODE</span></code> macro is used for this purpose.</p>
<p>MAME provides macros and helper functions for producing commonly used
input codes, including standard keyboard keys and
mouse/joystick/lightgun axes and buttons.</p>
</section>
<section id="input-sequence">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Input sequence</a><a class="headerlink" href="#input-sequence" title="Link to this heading">¶</a></h3>
<p>An input sequence specifies a combination controls that can be assigned
to an input.  The name refers to the fact that it is implemented as a
sequence container with input codes as elements.  It is somewhat
misleading, as input sequences are interpreted using instantaneous
control values.  Input sequences are interpreted differently for switch
and axis input.</p>
<p>Input sequences for switch input must only contain input codes with the
item class set to switch along with the special <strong>or</strong> and <strong>not</strong> input
codes.  The input sequence is interpreted using sum-of-products logic.
A <strong>not</strong> code causes the value returned by the immediately following
code to be inverted.  The conjunction of values returned by successive
codes is evaluated until an <strong>or</strong> code is encountered.  If the current
value is 1 when an <strong>or</strong> code is encountered it is returned, otherwise
evaluation continues.</p>
<p>Input sequences for axis input can contain input codes with the item
class set to switch, absolute axis or relative axis along with the
special <strong>or</strong> and <strong>not</strong> codes.  It’s helpful to think of the input
sequence as containing one or more groups of input codes separated by
<strong>or</strong> codes:</p>
<ul class="simple">
<li><p>A <strong>not</strong> code causes the value returned by an immediately following
switch code to be inverted.  It has no effect on absolute or relative
axis codes.</p></li>
<li><p>Within a group, the conjunction of the values returned by switch codes
is evaluated.  If it is zero, the group is ignored.</p></li>
<li><p>Within a group, multiple axis values of the same type are summed.
Values returned by absolute axis codes are summed, and values returned
by relative axis codes are summed.</p></li>
<li><p>If any absolute axis code in a group returns a non-zero value, the sum
of relative axes in the group is ignored.  Any non-zero absolute axis
value takes precedence over relative axis values.</p></li>
<li><p>The same logic is applied when combining group values: group values
produced from the same axis type are summed, and values produced from
absolute axes take precedence over values produced from relative axes.</p></li>
<li><p>After the group values are summed, if the value was produced from
absolute axes it is clamped to the range -65,536 to 65,536 (values
produced from relative axes are not clamped).</p></li>
</ul>
<p>Emulation code rarely needs to deal with input sequences directly, as
they’re handled internally between the I/O port manager and input
manager.  The input manager also converts input sequences to and from
the token strings stored in configuration files and produces text for
displaying input sequences to users.</p>
<p>Plugins with controls or hotkeys need to use input sequences to allow
configuration.  Utility classes are provided to allow input sequences to
be entered by the user in a consistent way, and the input manager can be
used for conversions to and from configuration and display strings.  It
is very rare to need to directly manipulate input sequences.</p>
</section>
</section>
<section id="input-provider-modules">
<span id="inputsystem-providermodules"></span><h2><a class="toc-backref" href="#id11" role="doc-backlink">Input provider modules</a><a class="headerlink" href="#input-provider-modules" title="Link to this heading">¶</a></h2>
<p>Input provider modules are part of the OS-dependent layer (OSD), and are
not directly exposed to emulation and user interface code.  Input
provider modules are responsible for detecting available host input
devices, setting up input devices for the input manager, and providing
callbacks to read the current state of input device items.  Input
provider modules may also provide additional default input assignments
suitable for host input devices that are present.</p>
<p>The user is given a choice of input modules to use.  One input provider
module is used for each of the four input device classes (keyboard,
mouse, joystick and lightgun).  The available modules depend on the host
operating system and OSD implementation.  Different modules may use
different APIs, support different kinds of devices, or present devices
in different ways.</p>
</section>
<section id="player-positions">
<span id="inputsystem-playerpositions"></span><h2><a class="toc-backref" href="#id12" role="doc-backlink">Player positions</a><a class="headerlink" href="#player-positions" title="Link to this heading">¶</a></h2>
<p>MAME uses a concept called <em>player positions</em> to help manage input
assignments.  The number of player positions supported depends on the
I/O port field type:</p>
<ul class="simple">
<li><p>Ten player positions are supported for common game inputs, including
joystick, pedal, paddle, dial, trackball, lightgun and mouse.</p></li>
<li><p>Four player positions are supported for mahjong and hanafuda inputs.</p></li>
<li><p>One player position is supported for gambling system inputs.</p></li>
<li><p>Other inputs do not use player positions.  This includes coin slots,
arcade start buttons, tilt switches, service switches and
keyboard/keypad keys.</p></li>
</ul>
<p>The user can configure default input assignments per player position for
supported I/O port field types which are saved in the file
<strong>default.cfg</strong>.  These assignments are used for all systems unless the
device/system driver supplies its own default assignments, or the user
configures system-specific input assignments.</p>
<p>In order to facilitate development of reusable emulated devices with
inputs, particularly slot devices, the I/O port manager automatically
renumbers player positions when setting up the emulated system:</p>
<ul class="simple">
<li><p>The I/O port manager starts at player position 1 and begins
iterating the emulated device tree in depth first order, starting from
the root device.</p></li>
<li><p>If a device has I/O port fields that support player positions, they
are renumbered to start from the I/O port manager’s current player
position.</p></li>
<li><p>Before advancing to the next device, the I/O port manager sets its
current player position to the last seen player position plus one.</p></li>
</ul>
<p>For a simple example, consider what happens when you run a Sega Mega
Drive console with two game pads connected:</p>
<ul class="simple">
<li><p>The I/O port manager starts at player position 1 at the root device.</p></li>
<li><p>The first device encountered with I/O port fields that support player
positions is the first game pad.  The inputs are renumbered to start
at player position 1.  This has no visible effect, as the I/O port
fields are initially numbered starting at player position 1.</p></li>
<li><p>Before moving to the next device, the I/O port manager sets its
current player position to 2 (the last player position seen plus one).</p></li>
<li><p>The next device encountered with I/O port fields that support player
positions is the second game pad.  The inputs are renumbered to start
at player position 2.  This avoids I/O port field type conflicts with
the first game pad.</p></li>
<li><p>Before moving to the next device, the I/O port manager sets its
current player position to 3 (the last player position seen plus one).</p></li>
<li><p>No more devices with I/O port fields that support player positions are
encountered.</p></li>
</ul>
</section>
<section id="updating-i-o-port-fields">
<span id="inputsystem-updatingfields"></span><h2><a class="toc-backref" href="#id13" role="doc-backlink">Updating I/O port fields</a><a class="headerlink" href="#updating-i-o-port-fields" title="Link to this heading">¶</a></h2>
<p>The I/O port manager updates I/O port fields once for each video frame
produced by the first emulated screen in the system.  How a field is
updated depends on whether it is a digital or analog field.</p>
<section id="updating-digital-fields">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Updating digital fields</a><a class="headerlink" href="#updating-digital-fields" title="Link to this heading">¶</a></h3>
<p>Updating digital I/O port fields is simple:</p>
<ul class="simple">
<li><p>The I/O port manager reads the current value for the field’s assigned
input sequence (via the input manager).</p></li>
<li><p>If the value is zero, the field’s default value is set.</p></li>
<li><p>If the value is non-zero, the binary complement of the field’s default
value is set.</p></li>
</ul>
</section>
<section id="updating-absolute-analog-fields">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Updating absolute analog fields</a><a class="headerlink" href="#updating-absolute-analog-fields" title="Link to this heading">¶</a></h3>
<p>Updating absolute analog I/O port fields is more complex due to the need
to support a variety of control setups:</p>
<ul class="simple">
<li><p>The I/O port manager reads the current value for the field’s assigned
axis input sequence (via the input manager).</p></li>
<li><p>If the current value changed since the last update and the input
device item that produced the current value was an absolute axis, the
field’s value is set to the current value scaled to the correct range,
and no further processing is performed.</p></li>
<li><p>If the current value is non-zero and the input device item that
produced the current value was a relative axis, the current value is
added to the field’s value, scaled by the field’s sensitivity setting.</p></li>
<li><p>The I/O port manager reads the current value for the field’s assigned
increment input sequence (via the input manager); if this value is
non-zero, the field’s increment/decrement speed setting value is added
to its value, scaled by its sensitivity setting.</p></li>
<li><p>The I/O port manager reads the current value for the field’s assigned
decrement input sequence (via the input manager); if this value is
non-zero, the field’s increment/decrement speed setting value is
subtracted from its value, scaled by its sensitivity setting.</p></li>
<li><p>If the current axis input, increment input and decrement input values
are all zero, but either or both of the increment input and decrement
input values were non-zero the last time the field’s value changed in
response to user input, the field’s auto-centring speed setting value
is added to or subtracted from its value to move it toward its default
value.</p></li>
</ul>
<p>Note that the sensitivity setting value for absolute analog fields
affects the response to relative axis input device items and
increment/decrement inputs, but it does not affect the response to
absolute axis input device items or the auto-centring speed.</p>
</section>
<section id="updating-relative-analog-fields">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Updating relative analog fields</a><a class="headerlink" href="#updating-relative-analog-fields" title="Link to this heading">¶</a></h3>
<p>Relative analog I/O port fields also need special handling to cater for
multiple control setups, but they are a little simpler than absolute
analog fields:</p>
<ul class="simple">
<li><p>The I/O port manager reads the current value for the field’s assigned
axis input sequence (via the input manager).</p></li>
<li><p>If the current value is non-zero and the input device item that
produced the current value was an absolute axis, the current value is
added to the field’s value, scaled by the field’s sensitivity setting,
and no further processing is performed.</p></li>
<li><p>If the current value is non-zero and the input device item that
produced the current value was a relative axis, the current value is
added to the field’s value, scaled by the field’s sensitivity setting.</p></li>
<li><p>The I/O port manager reads the current value for the field’s assigned
increment input sequence (via the input manager); if this value is
non-zero, the field’s increment/decrement speed setting value is added
to its value, scaled by its sensitivity setting.</p></li>
<li><p>The I/O port manager reads the current value for the field’s assigned
decrement input sequence (via the input manager); if this value is
non-zero, the field’s increment/decrement speed setting value is
subtracted from its value, scaled by its sensitivity setting.</p></li>
</ul>
<p>Note that the sensitivity setting value for relative analog fields
affects the response to all user input.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="object_finders.html" class="btn btn-neutral float-left" title="Object Finders" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="device_memory_interface.html" class="btn btn-neutral float-right" title="The device_memory_interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1997-2025, MAMEdev and contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>